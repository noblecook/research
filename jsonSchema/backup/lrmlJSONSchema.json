{
	"$defs": {
		".lrml:Agent": {
			"$ref": "#/$defs/lrml:Agent.type.def",
			"description": "an entity that acts or has the capability to act."
		},
		".lrml:Agents": {
			"$ref": "#/$defs/lrml:AgentCollection.type.def",
			"description": "a collection where every member is an Agent."
		},
		".lrml:Alternatives": {
			"$ref": "#/$defs/lrml:AlternativeCollection.type.def",
			"description": "a mutually exclusive collection where every member is a LegalRuleML\n                rendering of one or more Legal Norms."
		},
		".lrml:Association": {
			"$ref": "#/$defs/lrml:Association.type.def",
			"description": "a partial description of the extension of some relations where each\n                non-target entity is paired with every target entity. "
		},
		".lrml:Associations": {
			"$ref": "#/$defs/lrml:AssociationCollection.type.def",
			"description": "a collection where every member is an Association."
		},
		".lrml:Authorities": {
			"$ref": "#/$defs/lrml:AuthorityCollection.type.def",
			"description": "a collection where every member is an Authority."
		},
		".lrml:Authority": {
			"$ref": "#/$defs/lrml:Authority.type.def",
			"description": "a person or organization with the power to create, endorse, or enforce\n                Legal Norms."
		},
		".lrml:AuxiliaryParty": {
			"$ref": "#/$defs/lrml:AuxiliaryParty.type.def",
			"description": "a role in a Deontic Specification to which the Deontic Specification\n                is related, but not primarily directed."
		},
		".lrml:Bearer": {
			"$ref": "#/$defs/lrml:Bearer.type.def",
			"description": "a role in a Deontic Specification to which the Deontic Specification\n                is primarily directed."
		},
		".lrml:Comment": {
			"$ref": "#/$defs/lrml:Comment.type.def",
			"description": "a comment, which has with no semantic effect."
		},
		".lrml:Compliance": {
			"$ref": "#/$defs/lrml:Compliance.type.def",
			"description": "an indication that an Obligation has been fulfilled or a Prohibition\n                has not been violated."
		},
		".lrml:ConstitutiveStatement": {
			"$ref": "#/$defs/lrml:ConstitutiveStatement.type.def",
			"description": "a Legal Statement which defines concepts and does not prescribe\n                behaviours."
		},
		".lrml:Context": {
			"$ref": "#/$defs/lrml:Context.type.def",
			"description": "an application of Associations to their target entities within a\n                Scope."
		},
		".lrml:DefeasibleStrength": {
			"$ref": "#/$defs/lrml:DefeasibleStrength.type.def",
			"description": "an indication that, in the absence of information to the contrary,\n                where the premises of a Legal Rule hold, the conclusion of the Legal Rule\n                holds."
		},
		".lrml:Defeater": {
			"$ref": "#/$defs/lrml:Defeater.type.def",
			"description": "an indication that, in the absence of information to the contrary,\n                where the premises of a Legal Rule hold, the opposite of the conclusion of the Legal\n                Rule does not hold."
		},
		".lrml:FactualStatement": {
			"$ref": "#/$defs/lrml:FactualStatement.type.def",
			"description": "an expression of fact."
		},
		".lrml:Figure": {
			"$ref": "#/$defs/lrml:Figure.type.def",
			"description": "an instantiation of a function by an Actor."
		},
		".lrml:Figures": {
			"$ref": "#/$defs/lrml:FigureCollection.type.def",
			"description": "a collection where every member is a Figure."
		},
		".lrml:Jurisdiction": {
			"$ref": "#/$defs/lrml:Jurisdiction.type.def",
			"description": "a geographic area or subject-matter over which an Authority applies\n                its legal power."
		},
		".lrml:Jurisdictions": {
			"$ref": "#/$defs/lrml:JurisdictionCollection.type.def",
			"description": "a collection where every member is a Jurisdication."
		},
		".lrml:LegalReference": {
			"$ref": "#/$defs/lrml:LegalReference.type.def",
			"description": "a pair consisting of an internal ID and an enriched non-IRI\n                identifier, where the non-IRI is paired with some additional information that is\n                sufficient to disambiguate the non-IRI to a unique LegalSource."
		},
		".lrml:LegalReferences": {
			"$ref": "#/$defs/lrml:LegalReferenceCollection.type.def",
			"description": "a collection where every member is a\n                LegalReference."
		},
		".lrml:LegalRuleML": {
			"$ref": "#/$defs/lrml:LegalRuleML.type.def",
			"description": "a formal representation of one or more LegalSources using the\n                LegalRuleML Specifications."
		},
		".lrml:LegalSource": {
			"$ref": "#/$defs/lrml:LegalSource.type.def",
			"description": "a source of one or more Legal Norms formulated in any format and\n                endorsed by an Authority."
		},
		".lrml:LegalSources": {
			"$ref": "#/$defs/lrml:LegalSourceCollection.type.def",
			"description": "a collection where every member is a LegalSource."
		},
		".lrml:Obligation": {
			"$ref": "#/$defs/lrml:Obligation.type.def",
			"description": "a Deontic Specification for a state, an act, or a course of action to\n                which a Bearer is legally bound, and if it is not achieved or performed results in a\n                Violation."
		},
		".lrml:Override": {
			"$ref": "#/$defs/lrml:Override.type.def",
			"description": "an indication that a Legal Rule takes precedence over another Legal\n                Rule. The ordered pair of Legal Rules is an instance in a defeasible priority\n                relation."
		},
		".lrml:OverrideStatement": {
			"$ref": "#/$defs/lrml:OverrideStatement.type.def",
			"description": "a Legal Statement of an Override."
		},
		".lrml:Paraphrase": {
			"$ref": "#/$defs/lrml:Paraphrase.type.def",
			"description": "a natural language rendering of a Legal  Rule or fragment of it that\n                is an alternative to its Legal Source(s)."
		},
		".lrml:PenaltyStatement": {
			"$ref": "#/$defs/lrml:PenaltyStatement.type.def",
			"description": "a Legal Statement of a sanction (e.g. a punishment or a\n                correction)."
		},
		".lrml:Permission": {
			"$ref": "#/$defs/lrml:Permission.type.def",
			"description": "a Deontic Specification for a state, an act, or a course of action\n                where the Bearer has no Obligation or Prohibition to the contrary. A weak Permission\n                is the absence of the Obligation or Prohibition to the contrary; a strong Permission\n                is an exception or derogation of the Obligation or Prohibition to the\n                contrary."
		},
		".lrml:Prefix": {
			"$ref": "#/$defs/lrml:Prefix.type.def",
			"description": "a non-empty prefix declaration in a LegalRuleML\n                document."
		},
		".lrml:PrescriptiveStatement": {
			"$ref": "#/$defs/lrml:PrescriptiveStatement.type.def",
			"description": "a Legal Statement which prescribes behaviours, e.g. with Permissions,\n                Obligations, or Prohibitions on states, actions, or courses of\n                actions."
		},
		".lrml:Prohibition": {
			"$ref": "#/$defs/lrml:Prohibition.type.def",
			"description": "a Deontic Specification for a state, an act, or a course of action to\n                which a Bearer is legally bound, and if it is achieved or performed results in a\n                Violation."
		},
		".lrml:Reference": {
			"$ref": "#/$defs/lrml:Reference.type.def",
			"description": "a pair consisting of an internal ID and an enriched non-IRI\n                identifier, where the non-IRI is paired with some additional information that is\n                sufficient to disambiguate the non-IRI to a unique Source."
		},
		".lrml:References": {
			"$ref": "#/$defs/lrml:ReferenceCollection.type.def",
			"description": "a collection where every member is a Reference."
		},
		".lrml:Reparation": {
			"$ref": "#/$defs/lrml:Reparation.type.def",
			"description": "an indication that a PenaltyStatement is linked with a\n                PrescriptiveStatement, meaning that a sanction may apply when the\n                PrescriptiveStatement entails a Deontic Specification, and there is a Violation of\n                the Deontic Specification."
		},
		".lrml:ReparationStatement": {
			"$ref": "#/$defs/lrml:ReparationStatement.type.def",
			"description": "a Legal Statement of a Reparation."
		},
		".lrml:Right": {
			"$ref": "#/$defs/lrml:Right.type.def",
			"description": "(see also Permission) a Deontic Specification that gives a Permission\n                to a party (the Bearer) and implies there are Obligations or Prohibitions on other\n                parties (the AuxiliaryParty) such that the Bearer can (eventually) exercise the\n                Right."
		},
		".lrml:Role": {
			"$ref": "#/$defs/lrml:Role.type.def",
			"description": "a function of or part played by an Actor relative to a LegalRuleML\n                expression."
		},
		".lrml:Roles": {
			"$ref": "#/$defs/lrml:RoleCollection.type.def",
			"description": "a collection where every member is a Role."
		},
		".lrml:Source": {
			"$ref": "#/$defs/lrml:Source.type.def",
			"description": "a source of information formulated in any format."
		},
		".lrml:Sources": {
			"$ref": "#/$defs/lrml:SourceCollection.type.def",
			"description": "a collection where every member is a Source."
		},
		".lrml:Statements": {
			"$ref": "#/$defs/lrml:StatementCollection.type.def",
			"description": "a collection where every member is a Legal Statement or a\n                FactualStatement."
		},
		".lrml:StrictStrength": {
			"$ref": "#/$defs/lrml:StrictStrength.type.def",
			"description": "an indication that where the premises of a Legal Rule are\n                indisputable, the conclusion of the Legal Rule is indisputable."
		},
		".lrml:SuborderList": {
			"$ref": "#/$defs/lrml:SuborderList.type.def",
			"description": "a Deontic Specification consisting of a sequence of Deontic\n                Specifications other than SuborderLists (at any depth).  When a SuborderList holds,\n                a Deontic Specification in the SuborderList holds if all Deontic Specifications that\n                precede it in the SuborderList have been violated."
		},
		".lrml:TemporalCharacteristic": {
			"$ref": "#/$defs/lrml:TemporalCharacteristic.type.def",
			"description": "a pair of Time with a qualification (consisting of a Legal Status and\n                a Status Development) that holds at the Time."
		},
		".lrml:TemporalCharacteristics": {
			"$ref": "#/$defs/lrml:TemporalCharacteristicCollection.type.def",
			"description": "a collection where every member is a Temporal\n                Characteristic."
		},
		".lrml:Times": {
			"$ref": "#/$defs/lrml:TimeCollection.type.def",
			"description": "a collection where every member is a Time."
		},
		".lrml:Violation": {
			"$ref": "#/$defs/lrml:Violation.type.def",
			"description": "an indication that an Obligation or Prohibition has been\n                violated."
		},
		".lrml:appliesAlternatives": {
			"$ref": "#/$defs/lrml:appliesAlternativeCollection.type.def",
			"description": "a collection of Alternatives applied by the\n                Context."
		},
		".lrml:appliesAssociation": {
			"$ref": "#/$defs/lrml:appliesAssociation.type.def",
			"description": "an Association applied by the Context."
		},
		".lrml:appliesAssociations": {
			"$ref": "#/$defs/lrml:appliesAssociationCollection.type.def",
			"description": "a collection of Associations applied by the\n                Context."
		},
		".lrml:appliesAuthority": {
			"$ref": "#/$defs/lrml:appliesAuthority.type.def",
			"description": "an Authority applied by the Context or Association."
		},
		".lrml:appliesJurisdiction": {
			"$ref": "#/$defs/lrml:appliesJurisdiction.type.def",
			"description": "a Jurisdiction applied by the Context or\n                Association."
		},
		".lrml:appliesModality": {
			"$ref": "#/$defs/lrml:appliesModality.type.def",
			"description": "the deontic mode that applies to a Deontic Specification in a Context\n                or Association."
		},
		".lrml:appliesPenalty": {
			"$ref": "#/$defs/lrml:appliesPenalty.type.def",
			"description": "the PenaltyStatement that is linked to a LegalRule in a\n                Reparation."
		},
		".lrml:appliesSource": {
			"$ref": "#/$defs/lrml:appliesSource.type.def",
			"description": "a LegalSource or Reference applied by the Context or\n                Association."
		},
		".lrml:appliesStrength": {
			"$ref": "#/$defs/lrml:appliesStrength.type.def",
			"description": "a (defeasible) Strength applied by the Context or\n                Association."
		},
		".lrml:appliesTemporalCharacteristic": {
			"$ref": "#/$defs/lrml:appliesTemporalCharacteristic.type.def",
			"description": "a TemporalCharacteristic applied by the Context or\n                Association."
		},
		".lrml:appliesTemporalCharacteristics": {
			"$ref": "#/$defs/lrml:appliesTemporalCharacteristics.type.def",
			"description": "a collection of TemporalCharacteristics applied by the Context or\n                Association."
		},
		".lrml:atTime": {
			"$ref": "#/$defs/lrml:atTime.type.def",
			"description": "the Time of the qualification of a\n                TemporalCharacteristic."
		},
		".lrml:filledBy": {
			"$ref": "#/$defs/lrml:filledBy.type.def",
			"description": "an Actor that fills the Role."
		},
		".lrml:forExpression": {
			"$ref": "#/$defs/lrml:forExpression.type.def",
			"description": "a LegalRuleML expression for which the Role is responsible e.g., the\n                expression was created or endorsed by the role."
		},
		".lrml:forStatus": {
			"$ref": "#/$defs/lrml:forStatus.type.def",
			"description": "the Legal Status of the qualification in a\n                TemporalCharacteristic."
		},
		".lrml:fromLegalSources": {
			"$ref": "#/$defs/lrml:fromLegalSources.type.def",
			"description": "the LegalSources from which the Alternatives are\n                derived."
		},
		".lrml:hasActor": {
			"$ref": "#/$defs/lrml:hasActor.type.def",
			"description": "an Actor that has the responsibility to fulfill the function of a\n                Figure."
		},
		".lrml:hasAgent": {
			"$ref": "#/$defs/lrml:hasAgent.type.def",
			"description": "an Agent in the collection."
		},
		".lrml:hasAgents": {
			"$ref": "#/$defs/lrml:hasAgentCollection.type.def",
			"description": "a collection of Agents."
		},
		".lrml:hasAlternative": {
			"$ref": "#/$defs/lrml:hasAlternative.type.def",
			"description": "a member of a collection of Alternatives."
		},
		".lrml:hasAlternatives": {
			"$ref": "#/$defs/lrml:hasAlternativeCollection.type.def",
			"description": "a collection of Alternatives."
		},
		".lrml:hasAssociation": {
			"$ref": "#/$defs/lrml:hasAssociation.type.def",
			"description": "an Association in the collection."
		},
		".lrml:hasAssociations": {
			"$ref": "#/$defs/lrml:hasAssociationCollection.type.def",
			"description": "a collection of Associations."
		},
		".lrml:hasAuthorities": {
			"$ref": "#/$defs/lrml:hasAuthorityCollection.type.def",
			"description": "a collection of Authorities."
		},
		".lrml:hasAuthority": {
			"$ref": "#/$defs/lrml:hasAuthority.type.def",
			"description": "an Authority in the collection."
		},
		".lrml:hasComment": {
			"$ref": "#/$defs/lrml:hasComment.type.def",
			"description": "a comment on the parent Node Element."
		},
		".lrml:hasContext": {
			"$ref": "#/$defs/lrml:hasContext.type.def",
			"description": "a Context described in the LegalRuleML document."
		},
		".lrml:hasFigure": {
			"$ref": "#/$defs/lrml:hasFigure.type.def",
			"description": "a Figure in the collection."
		},
		".lrml:hasFigures": {
			"$ref": "#/$defs/lrml:hasFigureCollection.type.def",
			"description": "a collection of Figures."
		},
		".lrml:hasFunction": {
			"$ref": "#/$defs/lrml:hasFunction.type.def",
			"description": "the function of a Figure."
		},
		".lrml:hasJurisdiction": {
			"$ref": "#/$defs/lrml:hasJurisdiction.type.def",
			"description": "a Jurisdiction in the collection."
		},
		".lrml:hasJurisdictions": {
			"$ref": "#/$defs/lrml:hasJurisdictionCollection.type.def",
			"description": "a collection of Jurisdictions."
		},
		".lrml:hasLegalReference": {
			"$ref": "#/$defs/lrml:hasLegalReference.type.def",
			"description": "a LegalReference in the collection."
		},
		".lrml:hasLegalReferences": {
			"$ref": "#/$defs/lrml:hasLegalReferenceCollection.type.def",
			"description": "a collection of LegalReferences."
		},
		".lrml:hasLegalSource": {
			"$ref": "#/$defs/lrml:hasLegalSource.type.def",
			"description": "a LegalSource in the collection."
		},
		".lrml:hasLegalSources": {
			"$ref": "#/$defs/lrml:hasLegalSourceCollection.type.def",
			"description": "a collection of LegalSources."
		},
		".lrml:hasMemberType": {
			"$ref": "#/$defs/lrml:hasMemberType.type.def",
			"description": " the type or class of members of the collection."
		},
		".lrml:hasParaphrase": {
			"$ref": "#/$defs/lrml:hasParaphrase.type.def",
			"description": "a Paraphrase of the parent Node Element (e.g. a Legal\n                Rule)."
		},
		".lrml:hasPrefix": {
			"$ref": "#/$defs/lrml:hasPrefix.type.def",
			"description": "a Prefix declared in the LegalRuleML document."
		},
		".lrml:hasQualification": {
			"$ref": "#/$defs/lrml:hasQualification.type.def",
			"description": "a qualification (e.g. an Override) of the\n                Statements."
		},
		".lrml:hasReference": {
			"$ref": "#/$defs/lrml:hasReference.type.def",
			"description": "a Reference in the collection."
		},
		".lrml:hasReferences": {
			"$ref": "#/$defs/lrml:hasReferenceCollection.type.def",
			"description": "a collection of References."
		},
		".lrml:hasRole": {
			"$ref": "#/$defs/lrml:hasRole.type.def",
			"description": "a Role in the collection."
		},
		".lrml:hasRoles": {
			"$ref": "#/$defs/lrml:hasRoleCollection.type.def",
			"description": "a collection of Roles."
		},
		".lrml:hasSource": {
			"$ref": "#/$defs/lrml:hasSource.type.def",
			"description": "a Source in the collection."
		},
		".lrml:hasSources": {
			"$ref": "#/$defs/lrml:hasSourceCollection.type.def",
			"description": "a collection of Sources."
		},
		".lrml:hasStatement": {
			"$ref": "#/$defs/lrml:hasStatement.type.def",
			"description": "a Legal Statement in the collection."
		},
		".lrml:hasStatements": {
			"$ref": "#/$defs/lrml:hasStatementCollection.type.def",
			"description": "a collection of Legal Statements."
		},
		".lrml:hasStatusDevelopment": {
			"$ref": "#/$defs/lrml:hasStatusDevelopment.type.def",
			"description": "the Status Development of the qualification in a\n                TemporalCharacteristic."
		},
		".lrml:hasStrength": {
			"$ref": "#/$defs/lrml:hasStrength.type.def",
			"description": "the (defeasible) Strength of the Legal Rule."
		},
		".lrml:hasTemporalCharacteristic": {
			"$ref": "#/$defs/lrml:hasTemporalCharacteristic.type.def",
			"description": "a TemporalCharacteristic in the collection."
		},
		".lrml:hasTemporalCharacteristics": {
			"$ref": "#/$defs/lrml:hasTemporalCharacteristics.type.def",
			"description": "a collection of TemporalCharacteristics."
		},
		".lrml:hasTime": {
			"$ref": "#/$defs/lrml:hasTime.type.def",
			"description": "a Time in the collection."
		},
		".lrml:hasTimes": {
			"$ref": "#/$defs/lrml:hasTimeCollection.type.def",
			"description": "a collection of Times."
		},
		".lrml:hasType": {
			"$ref": "#/$defs/lrml:hasType.type.def",
			"description": " the type or class of the parent Node Element."
		},
		".lrml:inScope": {
			"$ref": "#/$defs/lrml:inScope.type.def",
			"description": "the Statement or (collection of) Statements that the Context is\n                applied to."
		},
		".lrml:toPrescriptiveStatement": {
			"$ref": "#/$defs/lrml:toPrescriptiveStatement.type.def",
			"description": "the PrescriptiveStatement that is linked to a PenaltyStatement in a\n                Reparation."
		},
		".lrml:toTarget": {
			"$ref": "#/$defs/lrml:toTarget.type.def",
			"description": "the target to which properties are applied by the\n                Association."
		},
		".ruleml:After": {
			"$ref": "#/$defs/ruleml:BeforeAfter.type.def",
			"description": "<After>: an interval constructor \"d after (t)\". See\n                http://consumer.ruleml.org/1.02/glossary/#gloss-After"
		},
		".ruleml:Any": {
			"$ref": "#/$defs/ruleml:Any.type.def",
			"description": "<Any>: an interval constructor \"any t1, .., tn\". See\n                http://consumer.ruleml.org/1.02/glossary/#gloss-Any"
		},
		".ruleml:Atom": {
			"$ref": "#/$defs/ruleml:Atom.type.def",
			"description": "<Atom>: a predicate applied to arguments. See\n                http://deliberation.ruleml.org/1.02/glossary/#gloss-Atom"
		},
		".ruleml:Before": {
			"$ref": "#/$defs/ruleml:BeforeAfter.type.def",
			"description": "<Before>: an interval constructor \"d before (t)\". See\n                http://consumer.ruleml.org/1.02/glossary/#gloss-Before"
		},
		".ruleml:During": {
			"$ref": "#/$defs/ruleml:IntervalAlgebraOperation.type.def",
			"description": "<During>: an interval operator. See\n                http://consumer.ruleml.org/1.02/glossary/#gloss-During"
		},
		".ruleml:Equal": {
			"$ref": "#/$defs/ruleml:Equal.type.def",
			"description": "<Equal>: an equation between two terms. See\n                http://deliberation.ruleml.org/1.02/glossary/#gloss-Equal"
		},
		".ruleml:Every": {
			"$ref": "#/$defs/ruleml:Every.type.def",
			"description": "<Every>: an interval constructor \"every d\". See\n                http://consumer.ruleml.org/1.02/glossary/#gloss-Every"
		},
		".ruleml:Expr": {
			"$ref": "#/$defs/ruleml:Expr.type.def",
			"description": "<Expr>: a functional expression. See\n                http://deliberation.ruleml.org/1.02/glossary/#gloss-Expr"
		},
		".ruleml:Finishes": {
			"$ref": "#/$defs/ruleml:IntervalAlgebraOperation.type.def",
			"description": "<Finishes>: an interval operator. See\n                http://consumer.ruleml.org/1.02/glossary/#gloss-Finishes"
		},
		".ruleml:Fun": {
			"$ref": "#/$defs/ruleml:Fun.type.def",
			"description": "<Fun>: a type of name for functional operators. See\n                http://deliberation.ruleml.org/1.02/glossary/#gloss-Fun"
		},
		".ruleml:Ind": {
			"$ref": "#/$defs/ruleml:Ind.type.def",
			"description": "<Ind>: an individual constant. See\n                http://deliberation.ruleml.org/1.02/glossary/#gloss-Ind"
		},
		".ruleml:Init": {
			"$ref": "#/$defs/xs:string"
		},
		".ruleml:Meets": {
			"$ref": "#/$defs/ruleml:IntervalAlgebraOperation.type.def",
			"description": "<Meets>: an interval operator. See\n                http://consumer.ruleml.org/1.02/glossary/#gloss-Meets"
		},
		".ruleml:Naf": {
			"$ref": "#/$defs/ruleml:Naf.type.def"
		},
		".ruleml:Negation": {
			"$ref": "#/$defs/ruleml:Negation.type.def",
			"description": "<Negation>: a generic polymorphic negation, which is interpreted by the\n                intended semantics (i.e. semantic profile). See\n                http://consumer.ruleml.org/1.02/glossary/#gloss-Negation"
		},
		".ruleml:Operation": {
			"$ref": "#/$defs/ruleml:Operation.type.def",
			"description": "<Operation>: a generic polymorphic Operation, which is interpreted by\n                the intended semantics (i.e. semantic profile). See\n                http://consumer.ruleml.org/1.02/glossary/#gloss-Operation"
		},
		".ruleml:Overlaps": {
			"$ref": "#/$defs/ruleml:IntervalAlgebraOperation.type.def",
			"description": "<Overlaps>: an interval operator. See\n                http://consumer.ruleml.org/1.02/glossary/#gloss-Overlaps"
		},
		".ruleml:Precedes": {
			"$ref": "#/$defs/ruleml:IntervalAlgebraOperation.type.def",
			"description": "<Precedes>: an interval operator. See\n                http://consumer.ruleml.org/1.02/glossary/#gloss-Precedes"
		},
		".ruleml:Rel": {
			"$ref": "#/$defs/ruleml:Rel.type.def",
			"description": "<Rel>: a category of name used as the predicate of an atomic formula.\n                See  http://deliberation.ruleml.org/1.02/glossary/#gloss-Rel"
		},
		".ruleml:Skolem": {
			"$ref": "#/$defs/ruleml:Skolem.type.def",
			"description": "A Skolem individual constant, like RDF's blank nodes. See\n                http://deliberation.ruleml.org/1.02/glossary/#gloss-Skolem"
		},
		".ruleml:Starts": {
			"$ref": "#/$defs/ruleml:IntervalAlgebraOperation.type.def",
			"description": "<Starts>: an interval operator. See\n                http://consumer.ruleml.org/1.02/glossary/#gloss-Starts"
		},
		".ruleml:Succeeds": {
			"$ref": "#/$defs/ruleml:IntervalAlgebraOperation.type.def",
			"description": "<Succeeds>: an interval operator. See\n                http://consumer.ruleml.org/1.02/glossary/#gloss-Succeeds"
		},
		".ruleml:Timer": {
			"$ref": "#/$defs/ruleml:Timer.type.def",
			"description": "<Timer>: an interval constructor \"After t Every d\". See\n                http://consumer.ruleml.org/1.02/glossary/#gloss-Timer"
		},
		".ruleml:Var": {
			"$ref": "#/$defs/ruleml:Var.type.def",
			"description": "A logical variable, as in logic programming. See\n                http://deliberation.ruleml.org/1.02/glossary/#gloss-Var"
		},
		".ruleml:declare": {
			"$ref": "#/$defs/ruleml:declare.type.def",
			"description": "A role used for variables (<Var>) declared within a quantifier (<Forall>\n                or <Exists>). See\n                http://deliberation.ruleml.org/1.02/glossary/#gloss-declare"
		},
		".ruleml:degree": {
			"$ref": "#/$defs/ruleml:degree.type.def",
			"description": "An optional uncertainty value (between 0.0 and 1.0) that may be\n                assigned to simple formulas. See\n                http://deliberation.ruleml.org/1.02/glossary/#gloss-degree"
		},
		".ruleml:left": {
			"$ref": "#/$defs/ruleml:left.type.def",
			"description": "<left>: The left-hand side of an equation. See\n                http://deliberation.ruleml.org/1.02/glossary/#gloss-left"
		},
		".ruleml:oid": {
			"$ref": "#/$defs/ruleml:oid.type.def",
			"description": "<oid>: a label for Node elements. See\n                http://deliberation.ruleml.org/1.02/glossary/#gloss-oid"
		},
		".ruleml:repo": {
			"$ref": "#/$defs/ruleml:repo.type.def",
			"description": "A positional rest variable used in <Atom>s, <Expr>s and <Plex>s.  Note that\n                <Plex>s are generated, so <repo>s are only available above the Datalog sublanguage.\n                See http://www.ruleml.org/0.9/glossary/#gloss-repo"
		},
		".ruleml:resl": {
			"$ref": "#/$defs/ruleml:resl.type.def",
			"description": "A slotted rest variable used in <Atom>s, <Expr>s and <Plex>s.  Note that\n                <Plex>s are generated, so <resl>s are only available above the Datalog sublanguage. See\n                http://deliberation.ruleml.org/1.02/glossary/#gloss-resl"
		},
		".ruleml:right": {
			"$ref": "#/$defs/ruleml:right.type.def",
			"description": "<right>: The right-hand side of an equation. See\n                http://deliberation.ruleml.org/1.02/glossary/#gloss-right"
		},
		".ruleml:weak": {
			"$ref": "#/$defs/ruleml:weak.type.def"
		},
		"lrml:Agent.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Agent.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@sameAs": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:AgentCollection.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Agents": {
					"$ref": "#/$defs/.lrml:Agents"
				}
			},
			"required": [
				"lrml:Agents"
			],
			"type": "object"
		},
		"lrml:AgentCollection.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Agents": {
					"$ref": "#/$defs/.lrml:Agents"
				}
			},
			"required": [
				"lrml:Agents"
			],
			"type": "object"
		},
		"lrml:AgentCollection.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasAgent": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasAgent"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasAgent"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:AgentCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@memberType": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasAgent": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasAgent"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasAgent"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:AlternativeCollection.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Alternatives": {
					"$ref": "#/$defs/.lrml:Alternatives"
				}
			},
			"required": [
				"lrml:Alternatives"
			],
			"type": "object"
		},
		"lrml:AlternativeCollection.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Alternatives": {
					"$ref": "#/$defs/.lrml:Alternatives"
				}
			},
			"required": [
				"lrml:Alternatives"
			],
			"type": "object"
		},
		"lrml:AlternativeCollection.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:fromLegalSources": {
					"$ref": "#/$defs/.lrml:fromLegalSources"
				},
				"lrml:hasAlternative": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasAlternative"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasAlternative"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:AlternativeCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@memberType": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:fromLegalSources": {
					"$ref": "#/$defs/.lrml:fromLegalSources"
				},
				"lrml:hasAlternative": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasAlternative"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasAlternative"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:AndFormula.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Naf": {
					"$ref": "#/$defs/.ruleml:Naf"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:Association.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Association": {
					"$ref": "#/$defs/.lrml:Association"
				}
			},
			"required": [
				"lrml:Association"
			],
			"type": "object"
		},
		"lrml:Association.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Association": {
					"$ref": "#/$defs/.lrml:Association"
				}
			},
			"required": [
				"lrml:Association"
			],
			"type": "object"
		},
		"lrml:Association.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:appliesAuthority": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesAuthority"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesAuthority"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesJurisdiction": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesJurisdiction"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesJurisdiction"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesModality": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesModality"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesModality"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesSource": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesSource"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesSource"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesStrength": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesStrength"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesStrength"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesTemporalCharacteristic": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesTemporalCharacteristic"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesTemporalCharacteristic"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesTemporalCharacteristics": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesTemporalCharacteristics"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesTemporalCharacteristics"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				},
				"lrml:toTarget": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:toTarget"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:toTarget"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Association.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:appliesAuthority": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesAuthority"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesAuthority"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesJurisdiction": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesJurisdiction"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesJurisdiction"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesModality": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesModality"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesModality"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesSource": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesSource"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesSource"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesStrength": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesStrength"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesStrength"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesTemporalCharacteristic": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesTemporalCharacteristic"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesTemporalCharacteristic"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesTemporalCharacteristics": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesTemporalCharacteristics"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesTemporalCharacteristics"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				},
				"lrml:toTarget": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:toTarget"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:toTarget"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:AssociationCollection.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Associations": {
					"$ref": "#/$defs/.lrml:Associations"
				}
			},
			"required": [
				"lrml:Associations"
			],
			"type": "object"
		},
		"lrml:AssociationCollection.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Associations": {
					"$ref": "#/$defs/.lrml:Associations"
				}
			},
			"required": [
				"lrml:Associations"
			],
			"type": "object"
		},
		"lrml:AssociationCollection.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasAssociation": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasAssociation"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasAssociation"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:AssociationCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@memberType": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasAssociation": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasAssociation"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasAssociation"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Authority.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Authority": {
					"$ref": "#/$defs/.lrml:Authority"
				}
			},
			"required": [
				"lrml:Authority"
			],
			"type": "object"
		},
		"lrml:Authority.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Authority": {
					"$ref": "#/$defs/.lrml:Authority"
				}
			},
			"required": [
				"lrml:Authority"
			],
			"type": "object"
		},
		"lrml:Authority.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Authority.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@sameAs": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:AuthorityCollection.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Authorities": {
					"$ref": "#/$defs/.lrml:Authorities"
				}
			},
			"required": [
				"lrml:Authorities"
			],
			"type": "object"
		},
		"lrml:AuthorityCollection.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Authorities": {
					"$ref": "#/$defs/.lrml:Authorities"
				}
			},
			"required": [
				"lrml:Authorities"
			],
			"type": "object"
		},
		"lrml:AuthorityCollection.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasAuthority": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasAuthority"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasAuthority"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:AuthorityCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@memberType": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasAuthority": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasAuthority"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasAuthority"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:AuxiliaryParty.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				}
			},
			"type": "object"
		},
		"lrml:AuxiliaryParty.type.def": {
			"additionalProperties": false,
			"properties": {
				"@iri": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				}
			},
			"type": "object"
		},
		"lrml:Bearer.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				}
			},
			"type": "object"
		},
		"lrml:Bearer.type.def": {
			"additionalProperties": false,
			"properties": {
				"@iri": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				}
			},
			"type": "object"
		},
		"lrml:Comment.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Comment": {
					"$ref": "#/$defs/.lrml:Comment"
				}
			},
			"required": [
				"lrml:Comment"
			],
			"type": "object"
		},
		"lrml:Comment.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Comment": {
					"$ref": "#/$defs/.lrml:Comment"
				}
			},
			"required": [
				"lrml:Comment"
			],
			"type": "object"
		},
		"lrml:Comment.main": {
			"additionalProperties": false,
			"patternProperties": {
				"^\\w+$": {
				}
			},
			"properties": {
				"$": {
					"type": [
						"string",
						"number",
						"boolean"
					]
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"lrml:Comment.type.def": {
			"additionalProperties": false,
			"patternProperties": {
				"^\\w+$": {
				}
			},
			"properties": {
				"$": {
					"type": [
						"string",
						"number",
						"boolean"
					]
				},
				"@iri": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"lrml:Compliance.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				}
			},
			"type": "object"
		},
		"lrml:Compliance.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				}
			},
			"type": "object"
		},
		"lrml:ConclusionFormula.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:ConstitutiveAndFormula.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:ConstitutiveExistsFormula.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:ConstitutiveForallFormula.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:ConstitutiveNegFormula.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:ConstitutiveOrFormula.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:ConstitutivePremiseFormula.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:ConstitutiveStatement.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasTemplate": {
					"$ref": "#/$defs/lrml:hasTemplate-Constitutive.type.def",
					"description": "the template of a ConstitutiveStatement."
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:ConstitutiveStatement.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasTemplate": {
					"$ref": "#/$defs/lrml:hasTemplate-Constitutive.type.def",
					"description": "the template of a ConstitutiveStatement."
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:ConstitutiveStatementFormula.choice": {
			"additionalProperties": false,
			"properties": {
				"ruleml:Rule": {
					"$ref": "#/$defs/ruleml:ConstitutiveRule.type.def",
					"description": "a RuleML Rule encoding a Constitutive\n                        Statement."
				}
			},
			"required": [
				"ruleml:Rule"
			],
			"type": "object"
		},
		"lrml:Context.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Context": {
					"$ref": "#/$defs/.lrml:Context"
				}
			},
			"required": [
				"lrml:Context"
			],
			"type": "object"
		},
		"lrml:Context.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Context": {
					"$ref": "#/$defs/.lrml:Context"
				}
			},
			"required": [
				"lrml:Context"
			],
			"type": "object"
		},
		"lrml:Context.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:appliesAlternatives": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesAlternatives"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesAlternatives"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesAssociation": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesAssociation"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesAssociation"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesAssociations": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesAssociations"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesAssociations"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesAuthority": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesAuthority"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesAuthority"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesJurisdiction": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesJurisdiction"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesJurisdiction"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesModality": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesModality"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesModality"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesSource": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesSource"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesSource"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesStrength": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesStrength"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesStrength"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesTemporalCharacteristic": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesTemporalCharacteristic"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesTemporalCharacteristic"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesTemporalCharacteristics": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesTemporalCharacteristics"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesTemporalCharacteristics"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:inScope": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:inScope"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:inScope"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Context.type.def": {
			"additionalProperties": false,
			"properties": {
				"@hasCreationDate": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:appliesAlternatives": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesAlternatives"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesAlternatives"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesAssociation": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesAssociation"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesAssociation"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesAssociations": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesAssociations"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesAssociations"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesAuthority": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesAuthority"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesAuthority"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesJurisdiction": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesJurisdiction"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesJurisdiction"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesModality": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesModality"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesModality"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesSource": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesSource"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesSource"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesStrength": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesStrength"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesStrength"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesTemporalCharacteristic": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesTemporalCharacteristic"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesTemporalCharacteristic"
							},
							"type": "array"
						}
					]
				},
				"lrml:appliesTemporalCharacteristics": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesTemporalCharacteristics"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesTemporalCharacteristics"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:inScope": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:inScope"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:inScope"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:DefeasibleStrength.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				}
			},
			"type": "object"
		},
		"lrml:DefeasibleStrength.type.def": {
			"additionalProperties": false,
			"properties": {
				"@iri": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				}
			},
			"type": "object"
		},
		"lrml:Defeater.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				}
			},
			"type": "object"
		},
		"lrml:Defeater.type.def": {
			"additionalProperties": false,
			"properties": {
				"@iri": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				}
			},
			"type": "object"
		},
		"lrml:ExistsFormula.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:FactualStatement.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasTemplate": {
					"$ref": "#/$defs/lrml:hasTemplate-Factual.type.def",
					"description": "the template of a FactualStatement."
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:FactualStatement.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasTemplate": {
					"$ref": "#/$defs/lrml:hasTemplate-Factual.type.def",
					"description": "the template of a FactualStatement."
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Figure.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasActor": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasActor"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasActor"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasFunction": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasFunction"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasFunction"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Figure.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasActor": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasActor"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasActor"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasFunction": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasFunction"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasFunction"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:FigureCollection.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Figures": {
					"$ref": "#/$defs/.lrml:Figures"
				}
			},
			"required": [
				"lrml:Figures"
			],
			"type": "object"
		},
		"lrml:FigureCollection.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Figures": {
					"$ref": "#/$defs/.lrml:Figures"
				}
			},
			"required": [
				"lrml:Figures"
			],
			"type": "object"
		},
		"lrml:FigureCollection.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasFigure": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasFigure"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasFigure"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:FigureCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@memberType": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasFigure": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasFigure"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasFigure"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:ForallFormula.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:Jurisdiction.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Jurisdiction": {
					"$ref": "#/$defs/.lrml:Jurisdiction"
				}
			},
			"required": [
				"lrml:Jurisdiction"
			],
			"type": "object"
		},
		"lrml:Jurisdiction.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Jurisdiction": {
					"$ref": "#/$defs/.lrml:Jurisdiction"
				}
			},
			"required": [
				"lrml:Jurisdiction"
			],
			"type": "object"
		},
		"lrml:Jurisdiction.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Jurisdiction.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@sameAs": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:JurisdictionCollection.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Jurisdictions": {
					"$ref": "#/$defs/.lrml:Jurisdictions"
				}
			},
			"required": [
				"lrml:Jurisdictions"
			],
			"type": "object"
		},
		"lrml:JurisdictionCollection.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Jurisdictions": {
					"$ref": "#/$defs/.lrml:Jurisdictions"
				}
			},
			"required": [
				"lrml:Jurisdictions"
			],
			"type": "object"
		},
		"lrml:JurisdictionCollection.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasJurisdiction": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasJurisdiction"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasJurisdiction"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:JurisdictionCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@memberType": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasJurisdiction": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasJurisdiction"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasJurisdiction"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:LegalReference.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:LegalReference": {
					"$ref": "#/$defs/.lrml:LegalReference"
				}
			},
			"required": [
				"lrml:LegalReference"
			],
			"type": "object"
		},
		"lrml:LegalReference.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:LegalReference": {
					"$ref": "#/$defs/.lrml:LegalReference"
				}
			},
			"required": [
				"lrml:LegalReference"
			],
			"type": "object"
		},
		"lrml:LegalReference.type.def": {
			"additionalProperties": false,
			"properties": {
				"@refID": {
					"$ref": "#/$defs/lrml:refID.datatype"
				},
				"@refIDSystemName": {
					"$ref": "#/$defs/xs:string"
				},
				"@refIDSystemSource": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@refType": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@refersTo": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				}
			},
			"type": "object"
		},
		"lrml:LegalReferenceCollection.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:LegalReferences": {
					"$ref": "#/$defs/.lrml:LegalReferences"
				}
			},
			"required": [
				"lrml:LegalReferences"
			],
			"type": "object"
		},
		"lrml:LegalReferenceCollection.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:LegalReferences": {
					"$ref": "#/$defs/.lrml:LegalReferences"
				}
			},
			"required": [
				"lrml:LegalReferences"
			],
			"type": "object"
		},
		"lrml:LegalReferenceCollection.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasLegalReference": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasLegalReference"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasLegalReference"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:LegalReferenceCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@refIDSystemName": {
					"$ref": "#/$defs/xs:string"
				},
				"@refIDSystemSource": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@refType": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasLegalReference": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasLegalReference"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasLegalReference"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:LegalRuleML.type.def": {
			"additionalProperties": false,
			"description": "type of the LegalRuleML element  ",
			"properties": {
				"@hasCreationDate": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@xml:base": {
					"$ref": "#/$defs/xs:anyURI"
				},
				"lrml:hasAgents": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasAgents"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasAgents"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasAlternatives": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasAlternatives"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasAlternatives"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasAssociations": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasAssociations"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasAssociations"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasAuthorities": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasAuthorities"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasAuthorities"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasComment": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasComment"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasComment"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasContext": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasContext"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasContext"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasFigures": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasFigures"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasFigures"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasJurisdictions": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasJurisdictions"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasJurisdictions"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasLegalReferences": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasLegalReferences"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasLegalReferences"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasLegalSources": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasLegalSources"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasLegalSources"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasPrefix": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasPrefix"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasPrefix"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasReferences": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasReferences"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasReferences"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasRoles": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasRoles"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasRoles"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasSources": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasSources"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasSources"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasStatements": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasStatements"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasStatements"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasTemporalCharacteristics": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasTemporalCharacteristics"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasTemporalCharacteristics"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasTimes": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasTimes"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasTimes"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:LegalRuleMLDocument.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasAgents": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasAgents"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasAgents"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasAlternatives": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasAlternatives"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasAlternatives"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasAssociations": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasAssociations"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasAssociations"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasAuthorities": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasAuthorities"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasAuthorities"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasComment": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasComment"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasComment"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasContext": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasContext"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasContext"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasFigures": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasFigures"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasFigures"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasJurisdictions": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasJurisdictions"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasJurisdictions"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasLegalReferences": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasLegalReferences"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasLegalReferences"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasLegalSources": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasLegalSources"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasLegalSources"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasPrefix": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasPrefix"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasPrefix"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasReferences": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasReferences"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasReferences"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasRoles": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasRoles"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasRoles"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasSources": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasSources"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasSources"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasStatements": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasStatements"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasStatements"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasTemporalCharacteristics": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasTemporalCharacteristics"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasTemporalCharacteristics"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasTimes": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasTimes"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasTimes"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:LegalSource.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:LegalSource": {
					"$ref": "#/$defs/.lrml:LegalSource"
				}
			},
			"required": [
				"lrml:LegalSource"
			],
			"type": "object"
		},
		"lrml:LegalSource.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:LegalSource": {
					"$ref": "#/$defs/.lrml:LegalSource"
				}
			},
			"required": [
				"lrml:LegalSource"
			],
			"type": "object"
		},
		"lrml:LegalSource.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@sameAs": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:LegalSourceCollection.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:LegalSources": {
					"$ref": "#/$defs/.lrml:LegalSources"
				}
			},
			"required": [
				"lrml:LegalSources"
			],
			"type": "object"
		},
		"lrml:LegalSourceCollection.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:LegalSources": {
					"$ref": "#/$defs/.lrml:LegalSources"
				}
			},
			"required": [
				"lrml:LegalSources"
			],
			"type": "object"
		},
		"lrml:LegalSourceCollection.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasLegalSource": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasLegalSource"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasLegalSource"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasLegalSources": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasLegalSources"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasLegalSources"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:LegalSourceCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@memberType": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasLegalSource": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasLegalSource"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasLegalSource"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasLegalSources": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasLegalSources"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasLegalSources"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:NegFormula.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:Obligation.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:formula": {
					"$ref": "#/$defs/ruleml:formula_Deontic.type.def",
					"description": "the formula of the deontic operator."
				},
				"ruleml:slot": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:slotDeontic.type.def",
							"description": "a role of the deontic operator and its\n                        filler."
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:slotDeontic.type.def",
								"description": "a role of the deontic operator and its\n                        filler."
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Obligation.type.def": {
			"additionalProperties": false,
			"properties": {
				"@iri": {
					"$ref": "#/$defs/ruleml:iri.value"
				},
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:formula": {
					"$ref": "#/$defs/ruleml:formula_Deontic.type.def",
					"description": "the formula of the deontic operator."
				},
				"ruleml:slot": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:slotDeontic.type.def",
							"description": "a role of the deontic operator and its\n                        filler."
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:slotDeontic.type.def",
								"description": "a role of the deontic operator and its\n                        filler."
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:OrFormula.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Naf": {
					"$ref": "#/$defs/.ruleml:Naf"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:Override.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				}
			},
			"type": "object"
		},
		"lrml:Override.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@over": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@under": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				}
			},
			"type": "object"
		},
		"lrml:OverrideStatement.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasTemplate": {
					"$ref": "#/$defs/lrml:hasTemplate-Override.type.def",
					"description": "the template of a OverrideStatement."
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:OverrideStatement.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasTemplate": {
					"$ref": "#/$defs/lrml:hasTemplate-Override.type.def",
					"description": "the template of a OverrideStatement."
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:OverrideStatementFormula.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				}
			},
			"required": [
				"lrml:Override"
			],
			"type": "object"
		},
		"lrml:Paraphrase.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Paraphrase": {
					"$ref": "#/$defs/.lrml:Paraphrase"
				}
			},
			"required": [
				"lrml:Paraphrase"
			],
			"type": "object"
		},
		"lrml:Paraphrase.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Paraphrase": {
					"$ref": "#/$defs/.lrml:Paraphrase"
				}
			},
			"required": [
				"lrml:Paraphrase"
			],
			"type": "object"
		},
		"lrml:Paraphrase.main": {
			"additionalProperties": false,
			"patternProperties": {
				"^\\w+$": {
				}
			},
			"properties": {
				"$": {
					"type": [
						"string",
						"number",
						"boolean"
					]
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"lrml:Paraphrase.type.def": {
			"additionalProperties": false,
			"patternProperties": {
				"^\\w+$": {
				}
			},
			"properties": {
				"$": {
					"type": [
						"string",
						"number",
						"boolean"
					]
				},
				"@iri": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"lrml:PenaltyStatement.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasTemplate": {
					"$ref": "#/$defs/lrml:hasTemplate-Penalty.type.def",
					"description": "the template of a PenaltyStatement."
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:PenaltyStatement.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasTemplate": {
					"$ref": "#/$defs/lrml:hasTemplate-Penalty.type.def",
					"description": "the template of a PenaltyStatement."
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:PenaltyStatementFormula.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:SuborderList": {
					"$ref": "#/$defs/.lrml:SuborderList"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:Permission.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:formula": {
					"$ref": "#/$defs/ruleml:formula_Deontic.type.def",
					"description": "the formula of the deontic operator."
				},
				"ruleml:slot": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:slotDeontic.type.def",
							"description": "a role of the deontic operator and its\n                        filler."
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:slotDeontic.type.def",
								"description": "a role of the deontic operator and its\n                        filler."
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Permission.type.def": {
			"additionalProperties": false,
			"properties": {
				"@iri": {
					"$ref": "#/$defs/ruleml:iri.value"
				},
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:formula": {
					"$ref": "#/$defs/ruleml:formula_Deontic.type.def",
					"description": "the formula of the deontic operator."
				},
				"ruleml:slot": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:slotDeontic.type.def",
							"description": "a role of the deontic operator and its\n                        filler."
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:slotDeontic.type.def",
								"description": "a role of the deontic operator and its\n                        filler."
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Prefix.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Prefix": {
					"$ref": "#/$defs/.lrml:Prefix"
				}
			},
			"required": [
				"lrml:Prefix"
			],
			"type": "object"
		},
		"lrml:Prefix.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Prefix": {
					"$ref": "#/$defs/.lrml:Prefix"
				}
			},
			"required": [
				"lrml:Prefix"
			],
			"type": "object"
		},
		"lrml:Prefix.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				}
			},
			"type": "object"
		},
		"lrml:Prefix.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@pre": {
					"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)$",
					"type": "string"
				},
				"@refID": {
					"$ref": "#/$defs/lrml:prerefID.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				}
			},
			"required": [
				"@refID"
			],
			"type": "object"
		},
		"lrml:PremiseFormula.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Naf": {
					"$ref": "#/$defs/.ruleml:Naf"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:PrescriptiveConclusionFormula.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:SuborderList": {
					"$ref": "#/$defs/.lrml:SuborderList"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:PrescriptiveStatement.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasTemplate": {
					"$ref": "#/$defs/lrml:hasTemplate-Prescriptive.type.def",
					"description": "the template of a PrescriptiveStatement."
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:PrescriptiveStatement.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasTemplate": {
					"$ref": "#/$defs/lrml:hasTemplate-Prescriptive.type.def",
					"description": "the template of a PrescriptiveStatement."
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:PrescriptiveStatementFormula.choice": {
			"additionalProperties": false,
			"properties": {
				"ruleml:Rule": {
					"$ref": "#/$defs/ruleml:PrescriptiveRule.type.def",
					"description": "a RuleML Rule encoding a Prescriptive\n                        Statement."
				}
			},
			"required": [
				"ruleml:Rule"
			],
			"type": "object"
		},
		"lrml:Prohibition.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:formula": {
					"$ref": "#/$defs/ruleml:formula_Deontic.type.def",
					"description": "the formula of the deontic operator."
				},
				"ruleml:slot": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:slotDeontic.type.def",
							"description": "a role of the deontic operator and its\n                        filler."
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:slotDeontic.type.def",
								"description": "a role of the deontic operator and its\n                        filler."
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Prohibition.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:formula": {
					"$ref": "#/$defs/ruleml:formula_Deontic.type.def",
					"description": "the formula of the deontic operator."
				},
				"ruleml:slot": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:slotDeontic.type.def",
							"description": "a role of the deontic operator and its\n                        filler."
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:slotDeontic.type.def",
								"description": "a role of the deontic operator and its\n                        filler."
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Reference.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Reference": {
					"$ref": "#/$defs/.lrml:Reference"
				}
			},
			"required": [
				"lrml:Reference"
			],
			"type": "object"
		},
		"lrml:Reference.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Reference": {
					"$ref": "#/$defs/.lrml:Reference"
				}
			},
			"required": [
				"lrml:Reference"
			],
			"type": "object"
		},
		"lrml:Reference.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				}
			},
			"type": "object"
		},
		"lrml:Reference.type.def": {
			"additionalProperties": false,
			"properties": {
				"@refID": {
					"$ref": "#/$defs/lrml:refID.datatype"
				},
				"@refIDSystemName": {
					"$ref": "#/$defs/xs:string"
				},
				"@refIDSystemSource": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@refType": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@refersTo": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				}
			},
			"type": "object"
		},
		"lrml:ReferenceCollection.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:References": {
					"$ref": "#/$defs/.lrml:References"
				}
			},
			"required": [
				"lrml:References"
			],
			"type": "object"
		},
		"lrml:ReferenceCollection.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:References": {
					"$ref": "#/$defs/.lrml:References"
				}
			},
			"required": [
				"lrml:References"
			],
			"type": "object"
		},
		"lrml:ReferenceCollection.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasReference": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasReference"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasReference"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:ReferenceCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@refIDSystemName": {
					"$ref": "#/$defs/xs:string"
				},
				"@refIDSystemSource": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@refType": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasReference": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasReference"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasReference"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Reparation.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:appliesPenalty": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesPenalty"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesPenalty"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"lrml:toPrescriptiveStatement": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:toPrescriptiveStatement"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:toPrescriptiveStatement"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Reparation.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:appliesPenalty": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:appliesPenalty"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:appliesPenalty"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"lrml:toPrescriptiveStatement": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:toPrescriptiveStatement"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:toPrescriptiveStatement"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:ReparationStatement.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasTemplate": {
					"$ref": "#/$defs/lrml:hasTemplate-Reparation.type.def",
					"description": "the template of a ReparationStatement."
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:ReparationStatement.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasTemplate": {
					"$ref": "#/$defs/lrml:hasTemplate-Reparation.type.def",
					"description": "the template of a ReparationStatement."
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:ReparationStatementFormula.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				}
			},
			"required": [
				"lrml:Reparation"
			],
			"type": "object"
		},
		"lrml:Right.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:formula": {
					"$ref": "#/$defs/ruleml:formula_Deontic.type.def",
					"description": "the formula of the deontic operator."
				},
				"ruleml:slot": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:slotDeontic.type.def",
							"description": "a role of the deontic operator and its\n                        filler."
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:slotDeontic.type.def",
								"description": "a role of the deontic operator and its\n                        filler."
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Right.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:formula": {
					"$ref": "#/$defs/ruleml:formula_Deontic.type.def",
					"description": "the formula of the deontic operator."
				},
				"ruleml:slot": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:slotDeontic.type.def",
							"description": "a role of the deontic operator and its\n                        filler."
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:slotDeontic.type.def",
								"description": "a role of the deontic operator and its\n                        filler."
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Role.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Role": {
					"$ref": "#/$defs/.lrml:Role"
				}
			},
			"required": [
				"lrml:Role"
			],
			"type": "object"
		},
		"lrml:Role.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Role": {
					"$ref": "#/$defs/.lrml:Role"
				}
			},
			"required": [
				"lrml:Role"
			],
			"type": "object"
		},
		"lrml:Role.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:filledBy": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:filledBy"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:filledBy"
							},
							"type": "array"
						}
					]
				},
				"lrml:forExpression": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:forExpression"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:forExpression"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Role.type.def": {
			"additionalProperties": false,
			"properties": {
				"@iri": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:filledBy": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:filledBy"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:filledBy"
							},
							"type": "array"
						}
					]
				},
				"lrml:forExpression": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:forExpression"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:forExpression"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:RoleCollection.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Roles": {
					"$ref": "#/$defs/.lrml:Roles"
				}
			},
			"required": [
				"lrml:Roles"
			],
			"type": "object"
		},
		"lrml:RoleCollection.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Roles": {
					"$ref": "#/$defs/.lrml:Roles"
				}
			},
			"required": [
				"lrml:Roles"
			],
			"type": "object"
		},
		"lrml:RoleCollection.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasRole": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasRole"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasRole"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:RoleCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@memberType": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasRole": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasRole"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasRole"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Source.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Source": {
					"$ref": "#/$defs/.lrml:Source"
				}
			},
			"required": [
				"lrml:Source"
			],
			"type": "object"
		},
		"lrml:Source.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Source": {
					"$ref": "#/$defs/.lrml:Source"
				}
			},
			"required": [
				"lrml:Source"
			],
			"type": "object"
		},
		"lrml:Source.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Source.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@sameAs": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:SourceCollection.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Sources": {
					"$ref": "#/$defs/.lrml:Sources"
				}
			},
			"required": [
				"lrml:Sources"
			],
			"type": "object"
		},
		"lrml:SourceCollection.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Sources": {
					"$ref": "#/$defs/.lrml:Sources"
				}
			},
			"required": [
				"lrml:Sources"
			],
			"type": "object"
		},
		"lrml:SourceCollection.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasSource": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasSource"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasSource"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasSources": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasSources"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasSources"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:SourceCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@memberType": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasSource": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasSource"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasSource"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasSources": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasSources"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasSources"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:StatementCollection.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasQualification": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasQualification"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasQualification"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasStatement": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasStatement"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasStatement"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasStatements": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasStatements"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasStatements"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:StatementCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@memberType": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasQualification": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasQualification"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasQualification"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasStatement": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasStatement"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasStatement"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasStatements": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasStatements"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasStatements"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:StrictStrength.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				}
			},
			"type": "object"
		},
		"lrml:StrictStrength.type.def": {
			"additionalProperties": false,
			"properties": {
				"@iri": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				}
			},
			"type": "object"
		},
		"lrml:SuborderList.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:formula": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:formula_Suborder.type.def",
							"description": "a formula of the suborder list."
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:formula_Suborder.type.def",
								"description": "a formula of the suborder list."
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:SuborderList.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:formula": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:formula_Suborder.type.def",
							"description": "a formula of the suborder list."
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:formula_Suborder.type.def",
								"description": "a formula of the suborder list."
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:TemporalCharacteristic.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:TemporalCharacteristic": {
					"$ref": "#/$defs/.lrml:TemporalCharacteristic"
				}
			},
			"required": [
				"lrml:TemporalCharacteristic"
			],
			"type": "object"
		},
		"lrml:TemporalCharacteristic.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:TemporalCharacteristic": {
					"$ref": "#/$defs/.lrml:TemporalCharacteristic"
				}
			},
			"required": [
				"lrml:TemporalCharacteristic"
			],
			"type": "object"
		},
		"lrml:TemporalCharacteristic.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:atTime": {
					"$ref": "#/$defs/.lrml:atTime"
				},
				"lrml:forStatus": {
					"$ref": "#/$defs/.lrml:forStatus"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasStatusDevelopment": {
					"$ref": "#/$defs/.lrml:hasStatusDevelopment"
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:TemporalCharacteristic.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:atTime": {
					"$ref": "#/$defs/.lrml:atTime"
				},
				"lrml:forStatus": {
					"$ref": "#/$defs/.lrml:forStatus"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasStatusDevelopment": {
					"$ref": "#/$defs/.lrml:hasStatusDevelopment"
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:TemporalCharacteristicCollection.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:TemporalCharacteristics": {
					"$ref": "#/$defs/.lrml:TemporalCharacteristics"
				}
			},
			"required": [
				"lrml:TemporalCharacteristics"
			],
			"type": "object"
		},
		"lrml:TemporalCharacteristicCollection.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:TemporalCharacteristics": {
					"$ref": "#/$defs/.lrml:TemporalCharacteristics"
				}
			},
			"required": [
				"lrml:TemporalCharacteristics"
			],
			"type": "object"
		},
		"lrml:TemporalCharacteristicCollection.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasTemporalCharacteristic": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasTemporalCharacteristic"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasTemporalCharacteristic"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:TemporalCharacteristicCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@memberType": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasTemporalCharacteristic": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasTemporalCharacteristic"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasTemporalCharacteristic"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Time.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				},
				"ruleml:arg": {
					"$ref": "#/$defs/ruleml:argTimeData.type.def",
					"description": "data for a time expression."
				}
			},
			"type": "object"
		},
		"lrml:TimeCollection.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"lrml:Times": {
					"$ref": "#/$defs/.lrml:Times"
				}
			},
			"required": [
				"lrml:Times"
			],
			"type": "object"
		},
		"lrml:TimeCollection.Node.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Times": {
					"$ref": "#/$defs/.lrml:Times"
				}
			},
			"required": [
				"lrml:Times"
			],
			"type": "object"
		},
		"lrml:TimeCollection.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasTime": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasTime"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasTime"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:TimeCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@memberType": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasMemberType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasMemberType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasMemberType"
							},
							"type": "array"
						}
					]
				},
				"lrml:hasTime": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasTime"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasTime"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:Violation.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				}
			},
			"type": "object"
		},
		"lrml:Violation.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/lrml:id.datatype"
				},
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@type": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				}
			},
			"type": "object"
		},
		"lrml:absIRI.datatype": {
			"description": "(absolute) IRI",
			"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]+\\:[\\w\\D]+)$",
			"type": "string"
		},
		"lrml:any.type.choice": {
			"additionalProperties": false,
			"patternProperties": {
				"^\\w+$": {
				}
			},
			"properties": {
				"$": {
					"type": [
						"string",
						"number",
						"boolean"
					]
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"lrml:appliesAlternativeCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:appliesAssociation.type.def": {
			"additionalProperties": false,
			"properties": {
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:appliesAssociationCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:appliesAuthority.type.def": {
			"additionalProperties": false,
			"properties": {
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:appliesJurisdiction.type.def": {
			"additionalProperties": false,
			"properties": {
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:appliesModality.type.def": {
			"additionalProperties": false,
			"properties": {
				"@iri": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:appliesPenalty.type.def": {
			"additionalProperties": false,
			"properties": {
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:appliesSource.type.def": {
			"additionalProperties": false,
			"properties": {
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:appliesStrength.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:DefeasibleStrength": {
					"$ref": "#/$defs/.lrml:DefeasibleStrength"
				},
				"lrml:Defeater": {
					"$ref": "#/$defs/.lrml:Defeater"
				},
				"lrml:StrictStrength": {
					"$ref": "#/$defs/.lrml:StrictStrength"
				}
			},
			"type": "object"
		},
		"lrml:appliesStrength.type.def": {
			"additionalProperties": false,
			"properties": {
				"@iri": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:DefeasibleStrength": {
					"$ref": "#/$defs/.lrml:DefeasibleStrength"
				},
				"lrml:Defeater": {
					"$ref": "#/$defs/.lrml:Defeater"
				},
				"lrml:StrictStrength": {
					"$ref": "#/$defs/.lrml:StrictStrength"
				}
			},
			"type": "object"
		},
		"lrml:appliesTemporalCharacteristic.type.def": {
			"additionalProperties": false,
			"properties": {
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:appliesTemporalCharacteristics.type.def": {
			"additionalProperties": false,
			"properties": {
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:argTimeData.content": {
			"additionalProperties": false,
			"properties": {
				"ruleml:Data": {
					"anyOf": [
						{
							"type": "string"
						},
						{
							"type": "string"
						},
						{
							"type": "string"
						}
					],
					"description": "a temporal data value."
				}
			},
			"required": [
				"ruleml:Data"
			],
			"type": "object"
		},
		"lrml:atTime.type.def": {
			"additionalProperties": false,
			"properties": {
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:body_ConstitutiveRule.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Naf": {
					"$ref": "#/$defs/.ruleml:Naf"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:body_Implies-const.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:body_PrescriptiveRule.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Naf": {
					"$ref": "#/$defs/.ruleml:Naf"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:commonCollectionItem.main": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"lrml:curie.datatype": {
			"description": "CURIE",
			"minLength": 1,
			"pattern": "^((([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)?\\:)?(/|[\\w\\D]|[\\w\\D]*|[\\w\\D]|[\\w\\D]*|[\\w\\D]?))$",
			"type": "string"
		},
		"lrml:curieOrAbsIRI.datatype": {
			"anyOf": [
				{
					"description": "CURIE",
					"minLength": 1,
					"pattern": "^((([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)?\\:)?(/|[\\w\\D]|[\\w\\D]*|[\\w\\D]|[\\w\\D]*|[\\w\\D]?))$",
					"type": "string"
				},
				{
					"description": "(absolute) IRI",
					"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]+\\:[\\w\\D]+)$",
					"type": "string"
				}
			],
			"description": "CURIE or (absolute) IRI"
		},
		"lrml:curieOrIRI.datatype": {
			"anyOf": [
				{
					"description": "CURIE",
					"minLength": 1,
					"pattern": "^((([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)?\\:)?(/|[\\w\\D]|[\\w\\D]*|[\\w\\D]|[\\w\\D]*|[\\w\\D]?))$",
					"type": "string"
				},
				{
					"type": "string"
				}
			],
			"description": "CURIE or IRI reference"
		},
		"lrml:filledBy.type.def": {
			"additionalProperties": false,
			"properties": {
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:forExpression.type.def": {
			"additionalProperties": false,
			"properties": {
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:forStatus.type.def": {
			"additionalProperties": false,
			"properties": {
				"@iri": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:formula_And-const.content": {
			"additionalProperties": false,
			"description": "From RuleML",
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:formula_Deontic.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:formula_Exists-const.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:formula_Forall-const.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:formula_Or-const.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:formula_Suborder.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:fromLegalSources.type.def": {
			"additionalProperties": false,
			"properties": {
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:hasActor.type.def": {
			"additionalProperties": false,
			"properties": {
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:hasAgent.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Agent": {
					"$ref": "#/$defs/.lrml:Agent"
				}
			},
			"required": [
				"lrml:Agent"
			],
			"type": "object"
		},
		"lrml:hasAgent.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Agent": {
					"$ref": "#/$defs/.lrml:Agent"
				}
			},
			"required": [
				"lrml:Agent"
			],
			"type": "object"
		},
		"lrml:hasAgentCollection.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Agents": {
					"$ref": "#/$defs/.lrml:Agents"
				}
			},
			"required": [
				"lrml:Agents"
			],
			"type": "object"
		},
		"lrml:hasAgentCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Agents": {
					"$ref": "#/$defs/.lrml:Agents"
				}
			},
			"required": [
				"lrml:Agents"
			],
			"type": "object"
		},
		"lrml:hasAlternative.type.def": {
			"additionalProperties": false,
			"properties": {
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:hasAlternativeCollection.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Alternatives": {
					"$ref": "#/$defs/.lrml:Alternatives"
				}
			},
			"required": [
				"lrml:Alternatives"
			],
			"type": "object"
		},
		"lrml:hasAlternativeCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Alternatives": {
					"$ref": "#/$defs/.lrml:Alternatives"
				}
			},
			"required": [
				"lrml:Alternatives"
			],
			"type": "object"
		},
		"lrml:hasAssociation.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Association": {
					"$ref": "#/$defs/.lrml:Association"
				}
			},
			"required": [
				"lrml:Association"
			],
			"type": "object"
		},
		"lrml:hasAssociation.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Association": {
					"$ref": "#/$defs/.lrml:Association"
				}
			},
			"required": [
				"lrml:Association"
			],
			"type": "object"
		},
		"lrml:hasAssociationCollection.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Associations": {
					"$ref": "#/$defs/.lrml:Associations"
				}
			},
			"required": [
				"lrml:Associations"
			],
			"type": "object"
		},
		"lrml:hasAssociationCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Associations": {
					"$ref": "#/$defs/.lrml:Associations"
				}
			},
			"required": [
				"lrml:Associations"
			],
			"type": "object"
		},
		"lrml:hasAuthority.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Authority": {
					"$ref": "#/$defs/.lrml:Authority"
				}
			},
			"required": [
				"lrml:Authority"
			],
			"type": "object"
		},
		"lrml:hasAuthority.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Authority": {
					"$ref": "#/$defs/.lrml:Authority"
				}
			},
			"required": [
				"lrml:Authority"
			],
			"type": "object"
		},
		"lrml:hasAuthorityCollection.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Authorities": {
					"$ref": "#/$defs/.lrml:Authorities"
				}
			},
			"required": [
				"lrml:Authorities"
			],
			"type": "object"
		},
		"lrml:hasAuthorityCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Authorities": {
					"$ref": "#/$defs/.lrml:Authorities"
				}
			},
			"required": [
				"lrml:Authorities"
			],
			"type": "object"
		},
		"lrml:hasComment.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Comment": {
					"$ref": "#/$defs/.lrml:Comment"
				}
			},
			"required": [
				"lrml:Comment"
			],
			"type": "object"
		},
		"lrml:hasComment.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Comment": {
					"$ref": "#/$defs/.lrml:Comment"
				}
			},
			"required": [
				"lrml:Comment"
			],
			"type": "object"
		},
		"lrml:hasContext.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Context": {
					"$ref": "#/$defs/.lrml:Context"
				}
			},
			"required": [
				"lrml:Context"
			],
			"type": "object"
		},
		"lrml:hasContext.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Context": {
					"$ref": "#/$defs/.lrml:Context"
				}
			},
			"required": [
				"lrml:Context"
			],
			"type": "object"
		},
		"lrml:hasFigure.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Figure": {
					"$ref": "#/$defs/.lrml:Figure"
				}
			},
			"required": [
				"lrml:Figure"
			],
			"type": "object"
		},
		"lrml:hasFigure.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Figure": {
					"$ref": "#/$defs/.lrml:Figure"
				}
			},
			"required": [
				"lrml:Figure"
			],
			"type": "object"
		},
		"lrml:hasFigureCollection.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Figures": {
					"$ref": "#/$defs/.lrml:Figures"
				}
			},
			"required": [
				"lrml:Figures"
			],
			"type": "object"
		},
		"lrml:hasFigureCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Figures": {
					"$ref": "#/$defs/.lrml:Figures"
				}
			},
			"required": [
				"lrml:Figures"
			],
			"type": "object"
		},
		"lrml:hasFunction.type.def": {
			"additionalProperties": false,
			"properties": {
				"@iri": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:hasJurisdiction.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Jurisdiction": {
					"$ref": "#/$defs/.lrml:Jurisdiction"
				}
			},
			"required": [
				"lrml:Jurisdiction"
			],
			"type": "object"
		},
		"lrml:hasJurisdiction.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Jurisdiction": {
					"$ref": "#/$defs/.lrml:Jurisdiction"
				}
			},
			"required": [
				"lrml:Jurisdiction"
			],
			"type": "object"
		},
		"lrml:hasJurisdictionCollection.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Jurisdictions": {
					"$ref": "#/$defs/.lrml:Jurisdictions"
				}
			},
			"required": [
				"lrml:Jurisdictions"
			],
			"type": "object"
		},
		"lrml:hasJurisdictionCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Jurisdictions": {
					"$ref": "#/$defs/.lrml:Jurisdictions"
				}
			},
			"required": [
				"lrml:Jurisdictions"
			],
			"type": "object"
		},
		"lrml:hasLegalReference.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:LegalReference": {
					"$ref": "#/$defs/.lrml:LegalReference"
				}
			},
			"required": [
				"lrml:LegalReference"
			],
			"type": "object"
		},
		"lrml:hasLegalReference.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:LegalReference": {
					"$ref": "#/$defs/.lrml:LegalReference"
				}
			},
			"required": [
				"lrml:LegalReference"
			],
			"type": "object"
		},
		"lrml:hasLegalReferenceCollection.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:LegalReferences": {
					"$ref": "#/$defs/.lrml:LegalReferences"
				}
			},
			"required": [
				"lrml:LegalReferences"
			],
			"type": "object"
		},
		"lrml:hasLegalReferenceCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:LegalReferences": {
					"$ref": "#/$defs/.lrml:LegalReferences"
				}
			},
			"required": [
				"lrml:LegalReferences"
			],
			"type": "object"
		},
		"lrml:hasLegalSource.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:LegalSource": {
					"$ref": "#/$defs/.lrml:LegalSource"
				}
			},
			"required": [
				"lrml:LegalSource"
			],
			"type": "object"
		},
		"lrml:hasLegalSource.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:LegalSource": {
					"$ref": "#/$defs/.lrml:LegalSource"
				}
			},
			"required": [
				"lrml:LegalSource"
			],
			"type": "object"
		},
		"lrml:hasLegalSourceCollection.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:LegalSources": {
					"$ref": "#/$defs/.lrml:LegalSources"
				}
			},
			"required": [
				"lrml:LegalSources"
			],
			"type": "object"
		},
		"lrml:hasLegalSourceCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:LegalSources": {
					"$ref": "#/$defs/.lrml:LegalSources"
				}
			},
			"required": [
				"lrml:LegalSources"
			],
			"type": "object"
		},
		"lrml:hasMemberType.type.def": {
			"additionalProperties": false,
			"properties": {
				"@iri": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:hasParaphrase.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Paraphrase": {
					"$ref": "#/$defs/.lrml:Paraphrase"
				}
			},
			"required": [
				"lrml:Paraphrase"
			],
			"type": "object"
		},
		"lrml:hasParaphrase.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Paraphrase": {
					"$ref": "#/$defs/.lrml:Paraphrase"
				}
			},
			"required": [
				"lrml:Paraphrase"
			],
			"type": "object"
		},
		"lrml:hasPrefix.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Prefix": {
					"$ref": "#/$defs/.lrml:Prefix"
				}
			},
			"required": [
				"lrml:Prefix"
			],
			"type": "object"
		},
		"lrml:hasPrefix.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Prefix": {
					"$ref": "#/$defs/.lrml:Prefix"
				}
			},
			"required": [
				"lrml:Prefix"
			],
			"type": "object"
		},
		"lrml:hasQualification.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:hasQualification.type.def": {
			"additionalProperties": false,
			"properties": {
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:hasReference.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Reference": {
					"$ref": "#/$defs/.lrml:Reference"
				}
			},
			"required": [
				"lrml:Reference"
			],
			"type": "object"
		},
		"lrml:hasReference.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Reference": {
					"$ref": "#/$defs/.lrml:Reference"
				}
			},
			"required": [
				"lrml:Reference"
			],
			"type": "object"
		},
		"lrml:hasReferenceCollection.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:References": {
					"$ref": "#/$defs/.lrml:References"
				}
			},
			"required": [
				"lrml:References"
			],
			"type": "object"
		},
		"lrml:hasReferenceCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:References": {
					"$ref": "#/$defs/.lrml:References"
				}
			},
			"required": [
				"lrml:References"
			],
			"type": "object"
		},
		"lrml:hasRole.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Role": {
					"$ref": "#/$defs/.lrml:Role"
				}
			},
			"required": [
				"lrml:Role"
			],
			"type": "object"
		},
		"lrml:hasRole.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Role": {
					"$ref": "#/$defs/.lrml:Role"
				}
			},
			"required": [
				"lrml:Role"
			],
			"type": "object"
		},
		"lrml:hasRoleCollection.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Roles": {
					"$ref": "#/$defs/.lrml:Roles"
				}
			},
			"required": [
				"lrml:Roles"
			],
			"type": "object"
		},
		"lrml:hasRoleCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Roles": {
					"$ref": "#/$defs/.lrml:Roles"
				}
			},
			"required": [
				"lrml:Roles"
			],
			"type": "object"
		},
		"lrml:hasSource.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Source": {
					"$ref": "#/$defs/.lrml:Source"
				}
			},
			"required": [
				"lrml:Source"
			],
			"type": "object"
		},
		"lrml:hasSource.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Source": {
					"$ref": "#/$defs/.lrml:Source"
				}
			},
			"required": [
				"lrml:Source"
			],
			"type": "object"
		},
		"lrml:hasSourceCollection.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Sources": {
					"$ref": "#/$defs/.lrml:Sources"
				}
			},
			"required": [
				"lrml:Sources"
			],
			"type": "object"
		},
		"lrml:hasSourceCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Sources": {
					"$ref": "#/$defs/.lrml:Sources"
				}
			},
			"required": [
				"lrml:Sources"
			],
			"type": "object"
		},
		"lrml:hasStatement.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:ConstitutiveStatement": {
					"$ref": "#/$defs/.lrml:ConstitutiveStatement"
				},
				"lrml:FactualStatement": {
					"$ref": "#/$defs/.lrml:FactualStatement"
				},
				"lrml:OverrideStatement": {
					"$ref": "#/$defs/.lrml:OverrideStatement"
				},
				"lrml:PenaltyStatement": {
					"$ref": "#/$defs/.lrml:PenaltyStatement"
				},
				"lrml:PrescriptiveStatement": {
					"$ref": "#/$defs/.lrml:PrescriptiveStatement"
				},
				"lrml:ReparationStatement": {
					"$ref": "#/$defs/.lrml:ReparationStatement"
				}
			},
			"type": "object"
		},
		"lrml:hasStatement.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:ConstitutiveStatement": {
					"$ref": "#/$defs/.lrml:ConstitutiveStatement"
				},
				"lrml:FactualStatement": {
					"$ref": "#/$defs/.lrml:FactualStatement"
				},
				"lrml:OverrideStatement": {
					"$ref": "#/$defs/.lrml:OverrideStatement"
				},
				"lrml:PenaltyStatement": {
					"$ref": "#/$defs/.lrml:PenaltyStatement"
				},
				"lrml:PrescriptiveStatement": {
					"$ref": "#/$defs/.lrml:PrescriptiveStatement"
				},
				"lrml:ReparationStatement": {
					"$ref": "#/$defs/.lrml:ReparationStatement"
				}
			},
			"type": "object"
		},
		"lrml:hasStatementCollection.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Statements": {
					"$ref": "#/$defs/.lrml:Statements"
				}
			},
			"required": [
				"lrml:Statements"
			],
			"type": "object"
		},
		"lrml:hasStatementCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Statements": {
					"$ref": "#/$defs/.lrml:Statements"
				}
			},
			"required": [
				"lrml:Statements"
			],
			"type": "object"
		},
		"lrml:hasStatusDevelopment.type.def": {
			"additionalProperties": false,
			"properties": {
				"@iri": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:hasStrength.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:DefeasibleStrength": {
					"$ref": "#/$defs/.lrml:DefeasibleStrength"
				},
				"lrml:Defeater": {
					"$ref": "#/$defs/.lrml:Defeater"
				},
				"lrml:StrictStrength": {
					"$ref": "#/$defs/.lrml:StrictStrength"
				}
			},
			"type": "object"
		},
		"lrml:hasStrength.type.def": {
			"additionalProperties": false,
			"properties": {
				"@iri": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:DefeasibleStrength": {
					"$ref": "#/$defs/.lrml:DefeasibleStrength"
				},
				"lrml:Defeater": {
					"$ref": "#/$defs/.lrml:Defeater"
				},
				"lrml:StrictStrength": {
					"$ref": "#/$defs/.lrml:StrictStrength"
				}
			},
			"type": "object"
		},
		"lrml:hasTemplate-Constitutive.content": {
			"additionalProperties": false,
			"properties": {
				"ruleml:Rule": {
					"$ref": "#/$defs/ruleml:ConstitutiveRule.type.def",
					"description": "a RuleML Rule encoding a Constitutive\n                        Statement."
				}
			},
			"required": [
				"ruleml:Rule"
			],
			"type": "object"
		},
		"lrml:hasTemplate-Constitutive.type.def": {
			"additionalProperties": false,
			"properties": {
				"ruleml:Rule": {
					"$ref": "#/$defs/ruleml:ConstitutiveRule.type.def",
					"description": "a RuleML Rule encoding a Constitutive\n                        Statement."
				}
			},
			"required": [
				"ruleml:Rule"
			],
			"type": "object"
		},
		"lrml:hasTemplate-Factual.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:hasTemplate-Factual.type.def": {
			"additionalProperties": false,
			"properties": {
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:hasTemplate-Override.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				}
			},
			"required": [
				"lrml:Override"
			],
			"type": "object"
		},
		"lrml:hasTemplate-Override.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				}
			},
			"required": [
				"lrml:Override"
			],
			"type": "object"
		},
		"lrml:hasTemplate-Penalty.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:SuborderList": {
					"$ref": "#/$defs/.lrml:SuborderList"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:hasTemplate-Penalty.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:SuborderList": {
					"$ref": "#/$defs/.lrml:SuborderList"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:hasTemplate-Prescriptive.content": {
			"additionalProperties": false,
			"properties": {
				"ruleml:Rule": {
					"$ref": "#/$defs/ruleml:PrescriptiveRule.type.def",
					"description": "a RuleML Rule encoding a Prescriptive\n                        Statement."
				}
			},
			"required": [
				"ruleml:Rule"
			],
			"type": "object"
		},
		"lrml:hasTemplate-Prescriptive.type.def": {
			"additionalProperties": false,
			"properties": {
				"ruleml:Rule": {
					"$ref": "#/$defs/ruleml:PrescriptiveRule.type.def",
					"description": "a RuleML Rule encoding a Prescriptive\n                        Statement."
				}
			},
			"required": [
				"ruleml:Rule"
			],
			"type": "object"
		},
		"lrml:hasTemplate-Reparation.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				}
			},
			"required": [
				"lrml:Reparation"
			],
			"type": "object"
		},
		"lrml:hasTemplate-Reparation.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				}
			},
			"required": [
				"lrml:Reparation"
			],
			"type": "object"
		},
		"lrml:hasTemporalCharacteristic.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:TemporalCharacteristic": {
					"$ref": "#/$defs/.lrml:TemporalCharacteristic"
				}
			},
			"required": [
				"lrml:TemporalCharacteristic"
			],
			"type": "object"
		},
		"lrml:hasTemporalCharacteristic.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:TemporalCharacteristic": {
					"$ref": "#/$defs/.lrml:TemporalCharacteristic"
				}
			},
			"required": [
				"lrml:TemporalCharacteristic"
			],
			"type": "object"
		},
		"lrml:hasTemporalCharacteristics.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:TemporalCharacteristics": {
					"$ref": "#/$defs/.lrml:TemporalCharacteristics"
				}
			},
			"required": [
				"lrml:TemporalCharacteristics"
			],
			"type": "object"
		},
		"lrml:hasTemporalCharacteristics.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:TemporalCharacteristics": {
					"$ref": "#/$defs/.lrml:TemporalCharacteristics"
				}
			},
			"required": [
				"lrml:TemporalCharacteristics"
			],
			"type": "object"
		},
		"lrml:hasTime.content": {
			"additionalProperties": false,
			"properties": {
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Timetype.def",
					"description": "a neutral temporal entity."
				}
			},
			"required": [
				"ruleml:Time"
			],
			"type": "object"
		},
		"lrml:hasTime.type.def": {
			"additionalProperties": false,
			"properties": {
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Timetype.def",
					"description": "a neutral temporal entity."
				}
			},
			"required": [
				"ruleml:Time"
			],
			"type": "object"
		},
		"lrml:hasTimeCollection.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Times": {
					"$ref": "#/$defs/.lrml:Times"
				}
			},
			"required": [
				"lrml:Times"
			],
			"type": "object"
		},
		"lrml:hasTimeCollection.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Times": {
					"$ref": "#/$defs/.lrml:Times"
				}
			},
			"required": [
				"lrml:Times"
			],
			"type": "object"
		},
		"lrml:hasType.type.def": {
			"additionalProperties": false,
			"properties": {
				"@iri": {
					"$ref": "#/$defs/lrml:iri.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:head_ConstitutiveRule.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:head_Implies-const.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:head_PrescriptiveRule.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:SuborderList": {
					"$ref": "#/$defs/.lrml:SuborderList"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:id.datatype": {
			"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)$",
			"type": "string"
		},
		"lrml:inScope.type.def": {
			"additionalProperties": false,
			"properties": {
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:iri.lrml.datatype": {
			"anyOf": [
				{
					"description": "CURIE",
					"minLength": 1,
					"pattern": "^((([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)?\\:)?(/|[\\w\\D]|[\\w\\D]*|[\\w\\D]|[\\w\\D]*|[\\w\\D]?))$",
					"type": "string"
				},
				{
					"type": "string"
				}
			]
		},
		"lrml:keyref.lrml.datatype": {
			"description": "refinement of xsd:anyURI that is a same-document relative IRI\n                reference with fragment identifier that belongs to the xsd:NCName lexical\n                space",
			"pattern": "^(#[A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)$",
			"type": "string"
		},
		"lrml:prerefID.datatype": {
			"pattern": "^([\\w\\D][\\w\\D]*)$",
			"type": "string"
		},
		"lrml:refID.datatype": {
			"type": "string"
		},
		"lrml:slotDeontic.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:AuxiliaryParty": {
					"$ref": "#/$defs/.lrml:AuxiliaryParty"
				},
				"lrml:Bearer": {
					"$ref": "#/$defs/.lrml:Bearer"
				},
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"lrml:strength.datatype": {
			"enum": [
				"StrictStrength",
				"defeasible",
				"defeater"
			],
			"type": "string"
		},
		"lrml:strong-const.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"lrml:toPrescriptiveStatement.type.def": {
			"additionalProperties": false,
			"properties": {
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:toTarget.type.def": {
			"additionalProperties": false,
			"properties": {
				"@keyref": {
					"$ref": "#/$defs/lrml:keyref.lrml.datatype"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": "object"
		},
		"lrml:torso-const.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"n1:ENTITIES": {
			"items": {
				"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)$",
				"type": "string"
			},
			"type": "array"
		},
		"n1:ENTITY": {
			"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)$",
			"type": "string"
		},
		"n1:ID": {
			"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)$",
			"type": "string"
		},
		"n1:IDREF": {
			"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)$",
			"type": "string"
		},
		"n1:IDREFS": {
			"items": {
				"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)$",
				"type": "string"
			},
			"type": "array"
		},
		"n1:NCName": {
			"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)$",
			"type": "string"
		},
		"n1:NMTOKEN": {
			"pattern": "^([\\d\\--\\.\\:A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]+)$",
			"type": "string"
		},
		"n1:NMTOKENS": {
			"items": {
				"pattern": "^([\\d\\--\\.\\:A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]+)$",
				"type": "string"
			},
			"type": "array"
		},
		"n1:NOTATION": {
			"type": "string"
		},
		"n1:Name": {
			"pattern": "^([\\:A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.\\:A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)$",
			"type": "string"
		},
		"n1:QName": {
			"type": "string"
		},
		"n1:anyURI": {
			"type": "string"
		},
		"n1:base64Binary": {
			"type": "string"
		},
		"n1:boolean": {
			"type": "boolean"
		},
		"n1:byte": {
			"maximum": 127,
			"minimum": -128,
			"type": "integer"
		},
		"n1:date": {
			"type": "string"
		},
		"n1:dateTime": {
			"type": "string"
		},
		"n1:decimal": {
			"type": "number"
		},
		"n1:double": {
			"type": "number"
		},
		"n1:duration": {
			"type": "string"
		},
		"n1:float": {
			"type": "number"
		},
		"n1:gDay": {
			"type": "string"
		},
		"n1:gMonth": {
			"type": "string"
		},
		"n1:gMonthDay": {
			"type": "string"
		},
		"n1:gYear": {
			"type": "string"
		},
		"n1:gYearMonth": {
			"type": "string"
		},
		"n1:hexBinary": {
			"type": "string"
		},
		"n1:int": {
			"maximum": 2147483647,
			"minimum": -2147483648,
			"type": "integer"
		},
		"n1:integer": {
			"type": "integer"
		},
		"n1:language": {
			"pattern": "^([A-Za-z]{1,8}(\\-[0-9A-Za-z]{1,8})*)$",
			"type": "string"
		},
		"n1:long": {
			"maximum": 9223372036854775807,
			"minimum": -9223372036854775808,
			"type": "integer"
		},
		"n1:negativeInteger": {
			"maximum": -1,
			"type": "integer"
		},
		"n1:nonNegativeInteger": {
			"minimum": 0,
			"type": "integer"
		},
		"n1:nonPositiveInteger": {
			"maximum": 0,
			"type": "integer"
		},
		"n1:normalizedString": {
			"type": "string"
		},
		"n1:positiveInteger": {
			"minimum": 1,
			"type": "integer"
		},
		"n1:short": {
			"maximum": 32767,
			"minimum": -32768,
			"type": "integer"
		},
		"n1:string": {
			"type": "string"
		},
		"n1:time": {
			"type": "string"
		},
		"n1:token": {
			"type": "string"
		},
		"n1:unsignedByte": {
			"maximum": 255,
			"minimum": 0,
			"type": "integer"
		},
		"n1:unsignedInt": {
			"maximum": 4294967295,
			"minimum": 0,
			"type": "integer"
		},
		"n1:unsignedLong": {
			"maximum": 18446744073709551615,
			"minimum": 0,
			"type": "integer"
		},
		"n1:unsignedShort": {
			"maximum": 65535,
			"minimum": 0,
			"type": "integer"
		},
		"ruleml:AbsIRI.datatype": {
			"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]+\\:[\\w\\D]+)$",
			"type": "string"
		},
		"ruleml:And.type.def": {
			"additionalProperties": false,
			"properties": {
				"@closure": {
					"$ref": "#/$defs/ruleml:closure.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:degree": {
					"$ref": "#/$defs/.ruleml:degree"
				},
				"ruleml:formula": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:formula_And.type.def",
							"description": "<formula>: contains a single formula. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-formula"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:formula_And.type.def",
								"description": "<formula>: contains a single formula. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-formula"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:Any.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:Any.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@type": {
					"$ref": "#/$defs/ruleml:type.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:Atom.type.def": {
			"additionalProperties": false,
			"properties": {
				"@closure": {
					"$ref": "#/$defs/ruleml:closure.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg.type.def",
							"description": "<arg>: one argument of an atomic formula. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-arg"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg.type.def",
								"description": "<arg>: one argument of an atomic formula. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-arg"
							},
							"type": "array"
						}
					]
				},
				"ruleml:degree": {
					"$ref": "#/$defs/.ruleml:degree"
				},
				"ruleml:oid": {
					"$ref": "#/$defs/.ruleml:oid"
				},
				"ruleml:op": {
					"$ref": "#/$defs/ruleml:op.type.def",
					"description": "<op>: edge (role) element for the predicate of an atomic\n                        formula. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-op"
				},
				"ruleml:repo": {
					"anyOf": [
						{
							"$ref": "#/$defs/.ruleml:repo"
						},
						{
							"items": {
								"$ref": "#/$defs/.ruleml:repo"
							},
							"type": "array"
						}
					]
				},
				"ruleml:resl": {
					"anyOf": [
						{
							"$ref": "#/$defs/.ruleml:resl"
						},
						{
							"items": {
								"$ref": "#/$defs/.ruleml:resl"
							},
							"type": "array"
						}
					]
				},
				"ruleml:slot": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:slot.type.def",
							"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:slot.type.def",
								"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:BeforeAfter.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:BeforeAfter.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@type": {
					"$ref": "#/$defs/ruleml:type.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:ConstitutiveRule-node.choice": {
			"additionalProperties": false,
			"properties": {
				"ruleml:Rule": {
					"$ref": "#/$defs/ruleml:ConstitutiveRule.type.def",
					"description": "a RuleML Rule encoding a Constitutive\n                        Statement."
				}
			},
			"required": [
				"ruleml:Rule"
			],
			"type": "object"
		},
		"ruleml:ConstitutiveRule.Node.def": {
			"additionalProperties": false,
			"properties": {
				"ruleml:Rule": {
					"$ref": "#/$defs/ruleml:ConstitutiveRule.type.def",
					"description": "a RuleML Rule encoding a Constitutive\n                        Statement."
				}
			},
			"required": [
				"ruleml:Rule"
			],
			"type": "object"
		},
		"ruleml:ConstitutiveRule.type.def": {
			"additionalProperties": false,
			"properties": {
				"@closure": {
					"$ref": "#/$defs/ruleml:closure.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@strength": {
					"$ref": "#/$defs/lrml:strength.datatype"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"lrml:hasStrength": {
					"$ref": "#/$defs/.lrml:hasStrength"
				},
				"ruleml:if": {
					"$ref": "#/$defs/ruleml:body_ConstitutiveRule.type.def",
					"description": "the premise (antecedent) of a constitutive\n                        statement."
				},
				"ruleml:then": {
					"$ref": "#/$defs/ruleml:head_ConstitutiveRule.type.def",
					"description": "the conclusion (consequent) of a constitutive\n                        statement."
				}
			},
			"type": "object"
		},
		"ruleml:Data_degree-node.choice": {
			"additionalProperties": false,
			"properties": {
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				}
			},
			"required": [
				"ruleml:Data"
			],
			"type": "object"
		},
		"ruleml:ENTITIES": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:ENTITIES"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:ENTITY": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:ENTITY"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:Equal.type.def": {
			"additionalProperties": false,
			"properties": {
				"@closure": {
					"$ref": "#/$defs/ruleml:closure.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@type": {
					"$ref": "#/$defs/ruleml:type.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:degree": {
					"$ref": "#/$defs/.ruleml:degree"
				},
				"ruleml:left": {
					"$ref": "#/$defs/.ruleml:left"
				},
				"ruleml:right": {
					"$ref": "#/$defs/.ruleml:right"
				}
			},
			"type": "object"
		},
		"ruleml:Equivalent.type.def": {
			"additionalProperties": false,
			"properties": {
				"@closure": {
					"$ref": "#/$defs/ruleml:closure.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:degree": {
					"$ref": "#/$defs/.ruleml:degree"
				},
				"ruleml:torso": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:torso.type.def",
							"description": "<torso>: contains one formula within an equivalence. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-torso\n                    "
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:torso.type.def",
								"description": "<torso>: contains one formula within an equivalence. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-torso\n                    "
							},
							"minItems": 1,
							"type": "array"
						}
					]
				}
			},
			"required": [
				"ruleml:torso"
			],
			"type": "object"
		},
		"ruleml:Every.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:Every.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@type": {
					"$ref": "#/$defs/ruleml:type.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:Exists.type.def": {
			"additionalProperties": false,
			"properties": {
				"@closure": {
					"$ref": "#/$defs/ruleml:closure.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:declare": {
					"anyOf": [
						{
							"$ref": "#/$defs/.ruleml:declare"
						},
						{
							"items": {
								"$ref": "#/$defs/.ruleml:declare"
							},
							"minItems": 1,
							"type": "array"
						}
					]
				},
				"ruleml:degree": {
					"$ref": "#/$defs/.ruleml:degree"
				},
				"ruleml:formula": {
					"$ref": "#/$defs/ruleml:formula_Exists.type.def",
					"description": "The formula role of a conjunctive (<And>) or disjunctive (<Or>)\n                        expression,  quantifier (<Forall> or <Exists>), or performative (<Assert>, <Query>\n                        or <Retract>). See http://deliberation.ruleml.org/1.02/glossary/#gloss-formula\n                        Within Exists..."
				}
			},
			"required": [
				"ruleml:declare",
				"ruleml:formula"
			],
			"type": "object"
		},
		"ruleml:Expr.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg.type.def",
							"description": "<arg>: one argument of an atomic formula. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-arg"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg.type.def",
								"description": "<arg>: one argument of an atomic formula. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-arg"
							},
							"type": "array"
						}
					]
				},
				"ruleml:op": {
					"$ref": "#/$defs/ruleml:op_Expr.type.def",
					"description": "Also an operator in functional expressions."
				},
				"ruleml:repo": {
					"anyOf": [
						{
							"$ref": "#/$defs/.ruleml:repo"
						},
						{
							"items": {
								"$ref": "#/$defs/.ruleml:repo"
							},
							"type": "array"
						}
					]
				},
				"ruleml:resl": {
					"anyOf": [
						{
							"$ref": "#/$defs/.ruleml:resl"
						},
						{
							"items": {
								"$ref": "#/$defs/.ruleml:resl"
							},
							"type": "array"
						}
					]
				},
				"ruleml:slot": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:slot.type.def",
							"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:slot.type.def",
								"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:Forall.type.def": {
			"additionalProperties": false,
			"properties": {
				"@closure": {
					"$ref": "#/$defs/ruleml:closure.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:declare": {
					"anyOf": [
						{
							"$ref": "#/$defs/.ruleml:declare"
						},
						{
							"items": {
								"$ref": "#/$defs/.ruleml:declare"
							},
							"minItems": 1,
							"type": "array"
						}
					]
				},
				"ruleml:degree": {
					"$ref": "#/$defs/.ruleml:degree"
				},
				"ruleml:formula": {
					"$ref": "#/$defs/ruleml:formula_Forall.type.def",
					"description": "The formula role of a conjunctive (<And>) or disjunctive (<Or>)\n                        expression,  quantifier (<Forall> or <Exists>), or performative (<Assert>, <Query>\n                        or <Retract>). See http://deliberation.ruleml.org/1.02/glossary/#gloss-formula\n                        within Forall..."
				}
			},
			"required": [
				"ruleml:declare",
				"ruleml:formula"
			],
			"type": "object"
		},
		"ruleml:Fun.type.def": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/ruleml:Fun.value"
				},
				"@iri": {
					"$ref": "#/$defs/ruleml:iri.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@type": {
					"$ref": "#/$defs/ruleml:type.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:Fun.value": {
			"description": "A functor contains the XSD datatype token.",
			"type": "string"
		},
		"ruleml:Function-node.choice": {
			"additionalProperties": false,
			"description": "an extension point for specializations of the function operator tag\n                name. ",
			"properties": {
				"ruleml:Fun": {
					"$ref": "#/$defs/.ruleml:Fun"
				}
			},
			"required": [
				"ruleml:Fun"
			],
			"type": "object"
		},
		"ruleml:Implies.type.def": {
			"additionalProperties": false,
			"properties": {
				"@closure": {
					"$ref": "#/$defs/ruleml:closure.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@material": {
					"$ref": "#/$defs/ruleml:material.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:degree": {
					"$ref": "#/$defs/.ruleml:degree"
				},
				"ruleml:if": {
					"$ref": "#/$defs/ruleml:body_Implies.type.def",
					"description": "<if>: contains the premise of the implication. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-if"
				},
				"ruleml:then": {
					"$ref": "#/$defs/ruleml:head_Implies.type.def",
					"description": "<then>: contains the conclusion of the implication. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-then"
				}
			},
			"required": [
				"ruleml:if",
				"ruleml:then"
			],
			"type": "object"
		},
		"ruleml:Ind.type.def": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/ruleml:Ind.value"
				},
				"@iri": {
					"$ref": "#/$defs/ruleml:iri.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@type": {
					"$ref": "#/$defs/ruleml:type.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:Ind.value": {
			"description": "The content model for individuals is the XSD datatype\n                token.",
			"type": "string"
		},
		"ruleml:IntervalAlgebraOperation.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
							},
							"minItems": 1,
							"type": "array"
						}
					]
				}
			},
			"required": [
				"ruleml:arg"
			],
			"type": "object"
		},
		"ruleml:IntervalAlgebraOperation.type.def": {
			"additionalProperties": false,
			"description": "Common Patterns for Interval Algebra",
			"properties": {
				"@closure": {
					"$ref": "#/$defs/ruleml:closure.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
							},
							"minItems": 1,
							"type": "array"
						}
					]
				}
			},
			"required": [
				"ruleml:arg"
			],
			"type": "object"
		},
		"ruleml:Interval_formula.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg_interval_formula.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg_interval_formula.type.def"
							},
							"type": "array"
						}
					]
				},
				"ruleml:degree": {
					"$ref": "#/$defs/.ruleml:degree"
				},
				"ruleml:oid": {
					"$ref": "#/$defs/.ruleml:oid"
				}
			},
			"type": "object"
		},
		"ruleml:Interval_formula.type.def": {
			"additionalProperties": false,
			"properties": {
				"@closure": {
					"$ref": "#/$defs/ruleml:closure.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@type": {
					"$ref": "#/$defs/ruleml:type.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg_interval_formula.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg_interval_formula.type.def"
							},
							"type": "array"
						}
					]
				},
				"ruleml:degree": {
					"$ref": "#/$defs/.ruleml:degree"
				},
				"ruleml:oid": {
					"$ref": "#/$defs/.ruleml:oid"
				}
			},
			"type": "object"
		},
		"ruleml:Interval_term.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:Interval_term.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@type": {
					"$ref": "#/$defs/ruleml:type.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:NCName": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:NCName"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:NMTOKEN": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:NMTOKEN"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:NMTOKENS": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:NMTOKENS"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:NOTATION": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:NOTATION"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:Naf.type.def": {
			"additionalProperties": false,
			"properties": {
				"@closure": {
					"$ref": "#/$defs/ruleml:closure.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:degree": {
					"$ref": "#/$defs/.ruleml:degree"
				},
				"ruleml:weak": {
					"$ref": "#/$defs/.ruleml:weak"
				}
			},
			"required": [
				"ruleml:weak"
			],
			"type": "object"
		},
		"ruleml:NafFormula.choice": {
			"additionalProperties": false,
			"description": "formulas allowed to belong to weak negation formulas include atomic\n                forumulas. ",
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:Name": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:Name"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:Neg.type.def": {
			"additionalProperties": false,
			"properties": {
				"@closure": {
					"$ref": "#/$defs/ruleml:closure.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:degree": {
					"$ref": "#/$defs/.ruleml:degree"
				},
				"ruleml:strong": {
					"$ref": "#/$defs/ruleml:strong.type.def",
					"description": "A role used for logical negation (<Neg>).        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-strong"
				}
			},
			"required": [
				"ruleml:strong"
			],
			"type": "object"
		},
		"ruleml:Negation.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:formula": {
					"$ref": "#/$defs/ruleml:formula-negation.type.def"
				}
			},
			"required": [
				"ruleml:formula"
			],
			"type": "object"
		},
		"ruleml:Negation.type.def": {
			"additionalProperties": false,
			"properties": {
				"@closure": {
					"$ref": "#/$defs/ruleml:closure.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@type": {
					"$ref": "#/$defs/ruleml:type.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:formula": {
					"$ref": "#/$defs/ruleml:formula-negation.type.def"
				}
			},
			"required": [
				"ruleml:formula"
			],
			"type": "object"
		},
		"ruleml:Operation.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:formula": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:formula-Operation.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:formula-Operation.type.def"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:Operation.type.def": {
			"additionalProperties": false,
			"properties": {
				"@closure": {
					"$ref": "#/$defs/ruleml:closure.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@type": {
					"$ref": "#/$defs/ruleml:type.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:formula": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:formula-Operation.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:formula-Operation.type.def"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:OperationFormula.choice": {
			"additionalProperties": false,
			"description": "formulas allowed to participate in generic operations include all\n                formulas allowed in conjunctions. Typically, this will be all logical formulas.\n            ",
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Naf": {
					"$ref": "#/$defs/.ruleml:Naf"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:Or.type.def": {
			"additionalProperties": false,
			"properties": {
				"@closure": {
					"$ref": "#/$defs/ruleml:closure.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:degree": {
					"$ref": "#/$defs/.ruleml:degree"
				},
				"ruleml:formula": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:formula_Or.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:formula_Or.type.def"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:Plex_Any.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg.type.def",
							"description": "<arg>: one argument of an atomic formula. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-arg"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg.type.def",
								"description": "<arg>: one argument of an atomic formula. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-arg"
							},
							"type": "array"
						}
					]
				},
				"ruleml:repo": {
					"$ref": "#/$defs/.ruleml:repo"
				},
				"ruleml:resl": {
					"$ref": "#/$defs/.ruleml:resl"
				},
				"ruleml:slot": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:slot.type.def",
							"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:slot.type.def",
								"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:Plex_repo.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg.type.def",
							"description": "<arg>: one argument of an atomic formula. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-arg"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg.type.def",
								"description": "<arg>: one argument of an atomic formula. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-arg"
							},
							"type": "array"
						}
					]
				},
				"ruleml:repo": {
					"$ref": "#/$defs/.ruleml:repo"
				}
			},
			"type": "object"
		},
		"ruleml:Plex_resl.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:resl": {
					"$ref": "#/$defs/.ruleml:resl"
				},
				"ruleml:slot": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:slot.type.def",
							"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:slot.type.def",
								"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:PrefixedCURIE.datatype": {
			"minLength": 1,
			"pattern": "^((([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)?\\:)(/|[\\w\\D]|[\\w\\D]*|[\\w\\D]|[\\w\\D]*|[\\w\\D]?))$",
			"type": "string"
		},
		"ruleml:PrescriptiveRule-node.choice": {
			"additionalProperties": false,
			"properties": {
				"ruleml:Rule": {
					"$ref": "#/$defs/ruleml:PrescriptiveRule.type.def",
					"description": "a RuleML Rule encoding a Prescriptive\n                        Statement."
				}
			},
			"required": [
				"ruleml:Rule"
			],
			"type": "object"
		},
		"ruleml:PrescriptiveRule.Node.def": {
			"additionalProperties": false,
			"properties": {
				"ruleml:Rule": {
					"$ref": "#/$defs/ruleml:PrescriptiveRule.type.def",
					"description": "a RuleML Rule encoding a Prescriptive\n                        Statement."
				}
			},
			"required": [
				"ruleml:Rule"
			],
			"type": "object"
		},
		"ruleml:PrescriptiveRule.type.def": {
			"additionalProperties": false,
			"properties": {
				"@closure": {
					"$ref": "#/$defs/ruleml:closure.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@strength": {
					"$ref": "#/$defs/lrml:strength.datatype"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"lrml:hasStrength": {
					"$ref": "#/$defs/.lrml:hasStrength"
				},
				"ruleml:if": {
					"$ref": "#/$defs/ruleml:body_PrescriptiveRule.type.def",
					"description": "the premise (antecedent) of a prescriptive\n                        statement."
				},
				"ruleml:then": {
					"$ref": "#/$defs/ruleml:head_PrescriptiveRule.type.def",
					"description": "the conclusion (consequent) of a prescriptive\n                        statement."
				}
			},
			"type": "object"
		},
		"ruleml:QName": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:QName"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:Rel.type.def": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/ruleml:Rel.value"
				},
				"@iri": {
					"$ref": "#/$defs/ruleml:iri.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@type": {
					"$ref": "#/$defs/ruleml:type.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:Rel.value": {
			"description": "The content model for relations is the XSD datatype\n                token.",
			"type": "string"
		},
		"ruleml:Relation-node.choice": {
			"additionalProperties": false,
			"properties": {
				"ruleml:Rel": {
					"$ref": "#/$defs/.ruleml:Rel"
				}
			},
			"required": [
				"ruleml:Rel"
			],
			"type": "object"
		},
		"ruleml:Rule.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:degree": {
					"$ref": "#/$defs/.ruleml:degree"
				},
				"ruleml:if": {
					"$ref": "#/$defs/ruleml:if_Rule.type.def",
					"description": "<if>: contains the premises of the rule. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-if"
				},
				"ruleml:then": {
					"$ref": "#/$defs/ruleml:then_Rule.type.def",
					"description": "<then>: contains the conclusion of the rule. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-then"
				}
			},
			"type": "object"
		},
		"ruleml:Rule.type.def": {
			"additionalProperties": false,
			"properties": {
				"@closure": {
					"$ref": "#/$defs/ruleml:closure.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@material": {
					"$ref": "#/$defs/ruleml:material.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:degree": {
					"$ref": "#/$defs/.ruleml:degree"
				},
				"ruleml:if": {
					"$ref": "#/$defs/ruleml:if_Rule.type.def",
					"description": "<if>: contains the premises of the rule. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-if"
				},
				"ruleml:then": {
					"$ref": "#/$defs/ruleml:then_Rule.type.def",
					"description": "<then>: contains the conclusion of the rule. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-then"
				}
			},
			"type": "object"
		},
		"ruleml:Skolem.type.def": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/ruleml:Skolem.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@type": {
					"$ref": "#/$defs/ruleml:type.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:Skolem.value": {
			"description": "The content model for skolems is the XSD datatype\n                token.",
			"type": "string"
		},
		"ruleml:Spatial_formula.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg_spatial.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg_spatial.type.def"
							},
							"type": "array"
						}
					]
				},
				"ruleml:content": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:spatial_anycontent.type"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:spatial_anycontent.type"
							},
							"type": "array"
						}
					]
				},
				"ruleml:degree": {
					"$ref": "#/$defs/.ruleml:degree"
				},
				"ruleml:oid": {
					"$ref": "#/$defs/.ruleml:oid"
				},
				"ruleml:repo": {
					"$ref": "#/$defs/.ruleml:repo"
				},
				"ruleml:resl": {
					"$ref": "#/$defs/.ruleml:resl"
				},
				"ruleml:slot": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:slot.type.def",
							"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:slot.type.def",
								"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:Spatial_formula.type.def": {
			"additionalProperties": false,
			"properties": {
				"@closure": {
					"$ref": "#/$defs/ruleml:closure.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@type": {
					"$ref": "#/$defs/ruleml:type.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg_spatial.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg_spatial.type.def"
							},
							"type": "array"
						}
					]
				},
				"ruleml:content": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:spatial_anycontent.type"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:spatial_anycontent.type"
							},
							"type": "array"
						}
					]
				},
				"ruleml:degree": {
					"$ref": "#/$defs/.ruleml:degree"
				},
				"ruleml:oid": {
					"$ref": "#/$defs/.ruleml:oid"
				},
				"ruleml:repo": {
					"$ref": "#/$defs/.ruleml:repo"
				},
				"ruleml:resl": {
					"$ref": "#/$defs/.ruleml:resl"
				},
				"ruleml:slot": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:slot.type.def",
							"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:slot.type.def",
								"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:Spatial_term.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg_spatial.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg_spatial.type.def"
							},
							"type": "array"
						}
					]
				},
				"ruleml:content": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:spatial_anycontent.type"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:spatial_anycontent.type"
							},
							"type": "array"
						}
					]
				},
				"ruleml:repo": {
					"$ref": "#/$defs/.ruleml:repo"
				},
				"ruleml:resl": {
					"$ref": "#/$defs/.ruleml:resl"
				},
				"ruleml:slot": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:slot.type.def",
							"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:slot.type.def",
								"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:Spatial_term.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@type": {
					"$ref": "#/$defs/ruleml:type.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg_spatial.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg_spatial.type.def"
							},
							"type": "array"
						}
					]
				},
				"ruleml:content": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:spatial_anycontent.type"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:spatial_anycontent.type"
							},
							"type": "array"
						}
					]
				},
				"ruleml:repo": {
					"$ref": "#/$defs/.ruleml:repo"
				},
				"ruleml:resl": {
					"$ref": "#/$defs/.ruleml:resl"
				},
				"ruleml:slot": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:slot.type.def",
							"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:slot.type.def",
								"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:String": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:string"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:Time.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Timetype.def",
					"description": "a neutral temporal entity."
				}
			},
			"required": [
				"ruleml:Time"
			],
			"type": "object"
		},
		"ruleml:Time.Node.def": {
			"additionalProperties": false,
			"properties": {
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Timetype.def",
					"description": "a neutral temporal entity."
				}
			},
			"required": [
				"ruleml:Time"
			],
			"type": "object"
		},
		"ruleml:TimeData.Node.choice": {
			"additionalProperties": false,
			"properties": {
				"ruleml:Data": {
					"anyOf": [
						{
							"type": "string"
						},
						{
							"type": "string"
						},
						{
							"type": "string"
						}
					],
					"description": "a temporal data value."
				}
			},
			"required": [
				"ruleml:Data"
			],
			"type": "object"
		},
		"ruleml:Time_formula.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg_time.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg_time.type.def"
							},
							"type": "array"
						}
					]
				},
				"ruleml:content": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:time_anycontent.type"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:time_anycontent.type"
							},
							"type": "array"
						}
					]
				},
				"ruleml:degree": {
					"$ref": "#/$defs/.ruleml:degree"
				},
				"ruleml:oid": {
					"$ref": "#/$defs/.ruleml:oid"
				},
				"ruleml:repo": {
					"$ref": "#/$defs/.ruleml:repo"
				},
				"ruleml:resl": {
					"$ref": "#/$defs/.ruleml:resl"
				},
				"ruleml:slot": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:slot.type.def",
							"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:slot.type.def",
								"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:Time_formula.type.def": {
			"additionalProperties": false,
			"properties": {
				"@closure": {
					"$ref": "#/$defs/ruleml:closure.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@type": {
					"$ref": "#/$defs/ruleml:type.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg_time.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg_time.type.def"
							},
							"type": "array"
						}
					]
				},
				"ruleml:content": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:time_anycontent.type"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:time_anycontent.type"
							},
							"type": "array"
						}
					]
				},
				"ruleml:degree": {
					"$ref": "#/$defs/.ruleml:degree"
				},
				"ruleml:oid": {
					"$ref": "#/$defs/.ruleml:oid"
				},
				"ruleml:repo": {
					"$ref": "#/$defs/.ruleml:repo"
				},
				"ruleml:resl": {
					"$ref": "#/$defs/.ruleml:resl"
				},
				"ruleml:slot": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:slot.type.def",
							"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:slot.type.def",
								"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:Time_term.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg_time.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg_time.type.def"
							},
							"type": "array"
						}
					]
				},
				"ruleml:content": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:time_anycontent.type"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:time_anycontent.type"
							},
							"type": "array"
						}
					]
				},
				"ruleml:repo": {
					"$ref": "#/$defs/.ruleml:repo"
				},
				"ruleml:resl": {
					"$ref": "#/$defs/.ruleml:resl"
				},
				"ruleml:slot": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:slot.type.def",
							"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:slot.type.def",
								"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:Time_term.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@type": {
					"$ref": "#/$defs/ruleml:type.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg_time.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg_time.type.def"
							},
							"type": "array"
						}
					]
				},
				"ruleml:content": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:time_anycontent.type"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:time_anycontent.type"
							},
							"type": "array"
						}
					]
				},
				"ruleml:repo": {
					"$ref": "#/$defs/.ruleml:repo"
				},
				"ruleml:resl": {
					"$ref": "#/$defs/.ruleml:resl"
				},
				"ruleml:slot": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:slot.type.def",
							"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:slot.type.def",
								"description": "A user-defined slot (property). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-slot"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:Timer.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:Timer.type.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@style": {
					"$ref": "#/$defs/ruleml:style.value"
				},
				"@type": {
					"$ref": "#/$defs/ruleml:type.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasParaphrase": {
					"$ref": "#/$defs/.lrml:hasParaphrase"
				},
				"ruleml:arg": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:arg_interval_term.type.def"
							},
							"type": "array"
						}
					]
				}
			},
			"type": "object"
		},
		"ruleml:Timetype.def": {
			"additionalProperties": false,
			"properties": {
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:hasComment": {
					"$ref": "#/$defs/.lrml:hasComment"
				},
				"lrml:hasType": {
					"anyOf": [
						{
							"$ref": "#/$defs/.lrml:hasType"
						},
						{
							"items": {
								"$ref": "#/$defs/.lrml:hasType"
							},
							"type": "array"
						}
					]
				},
				"ruleml:arg": {
					"$ref": "#/$defs/ruleml:argTimeData.type.def",
					"description": "data for a time expression."
				}
			},
			"type": "object"
		},
		"ruleml:Token": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:token"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:Var.type.def": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/ruleml:Var.value"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@type": {
					"$ref": "#/$defs/ruleml:type.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:Var.value": {
			"description": "The content model for variables is the XSD datatype\n                token.",
			"type": "string"
		},
		"ruleml:anySimpleType": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:anySimpleType"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:anyURI": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:anyURI"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:base": {
					"$ref": "#/$defs/xs:anyURI"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:anycontent.content": {
			"additionalProperties": false,
			"patternProperties": {
				"^\\w+$": {
				}
			},
			"properties": {
				"$": {
					"type": [
						"string",
						"number",
						"boolean"
					]
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:arg.content": {
			"additionalProperties": false,
			"description": "The content model of positional arguments for atomic formulas consists\n                of any single term.",
			"properties": {
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:arg.type.def": {
			"additionalProperties": false,
			"description": "The attribute @index is required for the positional argument role\n                (property).",
			"properties": {
				"@index": {
					"$ref": "#/$defs/ruleml:index.value"
				},
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"required": [
				"@index"
			],
			"type": "object"
		},
		"ruleml:argTimeData.type.def": {
			"additionalProperties": false,
			"properties": {
				"@index": {
					"$ref": "#/$defs/ruleml:index.value"
				},
				"ruleml:Data": {
					"anyOf": [
						{
							"type": "string"
						},
						{
							"type": "string"
						},
						{
							"type": "string"
						}
					],
					"description": "a temporal data value."
				}
			},
			"required": [
				"ruleml:Data",
				"@index"
			],
			"type": "object"
		},
		"ruleml:arg_interval_formula.content": {
			"additionalProperties": false,
			"properties": {
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:arg_interval_formula.type.def": {
			"additionalProperties": false,
			"properties": {
				"@index": {
					"$ref": "#/$defs/ruleml:index.value"
				},
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"required": [
				"@index"
			],
			"type": "object"
		},
		"ruleml:arg_interval_term.content": {
			"additionalProperties": false,
			"properties": {
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:arg_interval_term.type.def": {
			"additionalProperties": false,
			"properties": {
				"@index": {
					"$ref": "#/$defs/ruleml:index.value"
				},
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"required": [
				"@index"
			],
			"type": "object"
		},
		"ruleml:arg_spatial.content": {
			"additionalProperties": false,
			"properties": {
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:arg_spatial.type.def": {
			"additionalProperties": false,
			"properties": {
				"@index": {
					"$ref": "#/$defs/ruleml:index.value"
				},
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"required": [
				"@index"
			],
			"type": "object"
		},
		"ruleml:arg_time.content": {
			"additionalProperties": false,
			"properties": {
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:arg_time.type.def": {
			"additionalProperties": false,
			"properties": {
				"@index": {
					"$ref": "#/$defs/ruleml:index.value"
				},
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"required": [
				"@index"
			],
			"type": "object"
		},
		"ruleml:base64Binary": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:base64Binary"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:body_ConstitutiveRule.type.def": {
			"additionalProperties": false,
			"properties": {
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Naf": {
					"$ref": "#/$defs/.ruleml:Naf"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:body_Implies-const.type.def": {
			"additionalProperties": false,
			"properties": {
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:body_Implies.content": {
			"additionalProperties": false,
			"description": "The premise of an implication consists of a single\n                formula",
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Naf": {
					"$ref": "#/$defs/.ruleml:Naf"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:body_Implies.type.def": {
			"additionalProperties": false,
			"properties": {
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Naf": {
					"$ref": "#/$defs/.ruleml:Naf"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:body_PrescriptiveRule.type.def": {
			"additionalProperties": false,
			"properties": {
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Naf": {
					"$ref": "#/$defs/.ruleml:Naf"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:boolean": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:boolean"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:byte": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:byte"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:cardinality.value": {
			"minimum": 0,
			"type": "integer"
		},
		"ruleml:closure.value": {
			"anyOf": [
				{
					"minLength": 1,
					"pattern": "^((([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)?\\:)(/|[\\w\\D]|[\\w\\D]*|[\\w\\D]|[\\w\\D]*|[\\w\\D]?))$",
					"type": "string"
				},
				{
					"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]+\\:[\\w\\D]+)$",
					"type": "string"
				},
				{
					"enum": [
						"universal",
						"existential"
					],
					"type": "string"
				}
			]
		},
		"ruleml:date": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:date"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:dateTime": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:dateTime"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:decimal": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:decimal"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:declare.content": {
			"additionalProperties": false,
			"description": "a declaration element contains a single quantifiable\n                term",
			"properties": {
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"required": [
				"ruleml:Var"
			],
			"type": "object"
		},
		"ruleml:declare.type.def": {
			"additionalProperties": false,
			"properties": {
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"required": [
				"ruleml:Var"
			],
			"type": "object"
		},
		"ruleml:degree.content": {
			"additionalProperties": false,
			"description": "The degree edge element contains a single data\n                term.",
			"properties": {
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				}
			},
			"required": [
				"ruleml:Data"
			],
			"type": "object"
		},
		"ruleml:degree.type.def": {
			"additionalProperties": false,
			"properties": {
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				}
			},
			"required": [
				"ruleml:Data"
			],
			"type": "object"
		},
		"ruleml:double": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:double"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:duration": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:duration"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:float": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:float"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:formula-Operation.type.def": {
			"additionalProperties": false,
			"properties": {
				"@index": {
					"$ref": "#/$defs/ruleml:index.value"
				},
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Naf": {
					"$ref": "#/$defs/.ruleml:Naf"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"required": [
				"@index"
			],
			"type": "object"
		},
		"ruleml:formula-negation.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:formula-negation.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:formula_And-const.type.def": {
			"additionalProperties": false,
			"properties": {
				"@index": {
					"$ref": "#/$defs/ruleml:index.value"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:formula_And.content": {
			"additionalProperties": false,
			"description": "Formulas within conjunctions consist of a single\n                formula",
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Naf": {
					"$ref": "#/$defs/.ruleml:Naf"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:formula_And.type.def": {
			"additionalProperties": false,
			"properties": {
				"@index": {
					"$ref": "#/$defs/ruleml:index.value"
				},
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Naf": {
					"$ref": "#/$defs/.ruleml:Naf"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:formula_Deontic.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:formula_Exists-const.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:formula_Exists.content": {
			"additionalProperties": false,
			"description": "The formula role of existential quantifications contains a single\n                formula.",
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:formula_Exists.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:formula_Forall-const.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:formula_Forall.content": {
			"additionalProperties": false,
			"description": "The formula role of universal quantifications contains a single\n                formula. ",
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:formula_Forall.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:formula_Operation.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Naf": {
					"$ref": "#/$defs/.ruleml:Naf"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:formula_Or-const.type.def": {
			"additionalProperties": false,
			"properties": {
				"@index": {
					"$ref": "#/$defs/ruleml:index.value"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:formula_Or.content": {
			"additionalProperties": false,
			"description": "Formulas within disjunctions consist of a single\n                formula",
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Naf": {
					"$ref": "#/$defs/.ruleml:Naf"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:formula_Or.type.def": {
			"additionalProperties": false,
			"properties": {
				"@index": {
					"$ref": "#/$defs/ruleml:index.value"
				},
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Naf": {
					"$ref": "#/$defs/.ruleml:Naf"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:formula_Suborder.type.def": {
			"additionalProperties": false,
			"properties": {
				"@index": {
					"$ref": "#/$defs/ruleml:index.value"
				},
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"required": [
				"@index"
			],
			"type": "object"
		},
		"ruleml:gDay": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:gDay"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:gMonth": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:gMonth"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:gYear": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:gYear"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:gYearMonth": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:gYearMonth"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:head_ConstitutiveRule.type.def": {
			"additionalProperties": false,
			"properties": {
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:head_Implies-const.type.def": {
			"additionalProperties": false,
			"properties": {
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:head_Implies.content": {
			"additionalProperties": false,
			"description": "The conclusion of an implication consists of a single\n                formula.",
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:head_Implies.type.def": {
			"additionalProperties": false,
			"properties": {
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:head_PrescriptiveRule.type.def": {
			"additionalProperties": false,
			"properties": {
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:SuborderList": {
					"$ref": "#/$defs/.lrml:SuborderList"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:hexBinary": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:hexBinary"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:if_Rule.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Naf": {
					"$ref": "#/$defs/.ruleml:Naf"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:if_Rule.type.def": {
			"additionalProperties": false,
			"properties": {
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Naf": {
					"$ref": "#/$defs/.ruleml:Naf"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:index.value": {
			"minimum": 1,
			"type": "integer"
		},
		"ruleml:int": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:int"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:integer": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:integer"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:iri.value": {
			"anyOf": [
				{
					"minLength": 1,
					"pattern": "^((([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)?\\:)(/|[\\w\\D]|[\\w\\D]*|[\\w\\D]|[\\w\\D]*|[\\w\\D]?))$",
					"type": "string"
				},
				{
					"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]+\\:[\\w\\D]+)$",
					"type": "string"
				}
			]
		},
		"ruleml:key.value": {
			"anyOf": [
				{
					"minLength": 1,
					"pattern": "^((([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)?\\:)(/|[\\w\\D]|[\\w\\D]*|[\\w\\D]|[\\w\\D]*|[\\w\\D]?))$",
					"type": "string"
				},
				{
					"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]+\\:[\\w\\D]+)$",
					"type": "string"
				}
			]
		},
		"ruleml:keyref.value": {
			"pattern": "^(\\:[A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)$",
			"type": "string"
		},
		"ruleml:language": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:language"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:left.content": {
			"additionalProperties": false,
			"description": "The left-hand side role in an equation is filled by a\n                term.",
			"properties": {
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:left.type.def": {
			"additionalProperties": false,
			"properties": {
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:leftTerm.choice": {
			"additionalProperties": false,
			"description": "terms allowed in the left-hand side of an equation ",
			"properties": {
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:long": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:long"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:material.value": {
			"anyOf": [
				{
					"enum": [
						"yes"
					],
					"type": "string"
				},
				{
					"anyOf": [
						{
							"minLength": 1,
							"pattern": "^((([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)?\\:)(/|[\\w\\D]|[\\w\\D]*|[\\w\\D]|[\\w\\D]*|[\\w\\D]?))$",
							"type": "string"
						},
						{
							"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]+\\:[\\w\\D]+)$",
							"type": "string"
						},
						{
							"enum": [
								"no"
							],
							"type": "string"
						}
					]
				}
			]
		},
		"ruleml:material_default.value": {
			"enum": [
				"yes"
			],
			"type": "string"
		},
		"ruleml:material_non-default.value": {
			"anyOf": [
				{
					"minLength": 1,
					"pattern": "^((([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)?\\:)(/|[\\w\\D]|[\\w\\D]*|[\\w\\D]|[\\w\\D]*|[\\w\\D]?))$",
					"type": "string"
				},
				{
					"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]+\\:[\\w\\D]+)$",
					"type": "string"
				},
				{
					"enum": [
						"no"
					],
					"type": "string"
				}
			]
		},
		"ruleml:negativeInteger": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:negativeInteger"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:nonNegativeInteger": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:nonNegativeInteger"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:nonPositiveInteger": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:nonPositiveInteger"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:normalizedString": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:normalizedString"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:oid.content": {
			"additionalProperties": false,
			"description": "The object descriptor content model consists of any single term. Note:\n                this corrects an error in the oid content model of RuleML 1.0, where Var is allowed\n                in oid in bindatagroundlog and bindatagroundfact.",
			"properties": {
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:oid.type.def": {
			"additionalProperties": false,
			"properties": {
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:op.type.def": {
			"additionalProperties": false,
			"properties": {
				"ruleml:Rel": {
					"$ref": "#/$defs/.ruleml:Rel"
				}
			},
			"required": [
				"ruleml:Rel"
			],
			"type": "object"
		},
		"ruleml:op_Atom.content": {
			"additionalProperties": false,
			"description": "The operator role in the context of an atomic formula is filled by a\n                predicate.",
			"properties": {
				"ruleml:Rel": {
					"$ref": "#/$defs/.ruleml:Rel"
				}
			},
			"required": [
				"ruleml:Rel"
			],
			"type": "object"
		},
		"ruleml:op_Expr.content": {
			"additionalProperties": false,
			"description": "The operator role of an expression is filled by a\n                functor.",
			"properties": {
				"ruleml:Fun": {
					"$ref": "#/$defs/.ruleml:Fun"
				}
			},
			"required": [
				"ruleml:Fun"
			],
			"type": "object"
		},
		"ruleml:op_Expr.type.def": {
			"additionalProperties": false,
			"properties": {
				"ruleml:Fun": {
					"$ref": "#/$defs/.ruleml:Fun"
				}
			},
			"required": [
				"ruleml:Fun"
			],
			"type": "object"
		},
		"ruleml:positiveInteger": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:positiveInteger"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:repo.content": {
			"additionalProperties": false,
			"description": "The content model of a positional rest variable is a single\n                term.",
			"properties": {
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_repo.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        repo"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:repo.type.def": {
			"additionalProperties": false,
			"properties": {
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_repo.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        repo"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:repoTerm.choice": {
			"additionalProperties": false,
			"description": "terms allowed in positional rest variables include sequence markers.\n            ",
			"properties": {
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_repo.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        repo"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:resl.content": {
			"additionalProperties": false,
			"description": "The content model of a slotted rest variable is a single\n                term.",
			"properties": {
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_resl.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        resl"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:resl.type.def": {
			"additionalProperties": false,
			"properties": {
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_resl.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        resl"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:reslTerm.choice": {
			"additionalProperties": false,
			"description": "terms allowed in slotted rest variables. ",
			"properties": {
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_resl.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        resl"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:right.content": {
			"additionalProperties": false,
			"description": "The right-hand side role in an equation is filled by a\n                term.",
			"properties": {
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:right.type.def": {
			"additionalProperties": false,
			"properties": {
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:rightTerm.choice": {
			"additionalProperties": false,
			"description": "terms allowed in the right-hand side of an equation\n            ",
			"properties": {
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:short": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:short"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:slot.content": {
			"additionalProperties": false,
			"description": "The slot content model consists of a key (first position) and a filler\n                (second position).",
			"properties": {
				"ruleml:After": {
					"anyOf": [
						{
							"$ref": "#/$defs/.ruleml:After"
						},
						{
							"items": {
								"$ref": "#/$defs/.ruleml:After"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Any": {
					"anyOf": [
						{
							"$ref": "#/$defs/.ruleml:Any"
						},
						{
							"items": {
								"$ref": "#/$defs/.ruleml:Any"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Before": {
					"anyOf": [
						{
							"$ref": "#/$defs/.ruleml:Before"
						},
						{
							"items": {
								"$ref": "#/$defs/.ruleml:Before"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Data": {
					"anyOf": [
						{
							"$ref": "#/$defs/xs:anyType"
						},
						{
							"items": {
								"$ref": "#/$defs/xs:anyType"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Every": {
					"anyOf": [
						{
							"$ref": "#/$defs/.ruleml:Every"
						},
						{
							"items": {
								"$ref": "#/$defs/.ruleml:Every"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Expr": {
					"anyOf": [
						{
							"$ref": "#/$defs/.ruleml:Expr"
						},
						{
							"items": {
								"$ref": "#/$defs/.ruleml:Expr"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Ind": {
					"anyOf": [
						{
							"$ref": "#/$defs/.ruleml:Ind"
						},
						{
							"items": {
								"$ref": "#/$defs/.ruleml:Ind"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Interval": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:Interval_term.type.def",
							"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:Interval_term.type.def",
								"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Plex": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:Plex_Any.type.def",
							"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:Plex_Any.type.def",
								"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:Spatial_term.type.def",
							"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:Spatial_term.type.def",
								"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Time": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:Time_term.type.def",
							"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:Time_term.type.def",
								"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Timer": {
					"anyOf": [
						{
							"$ref": "#/$defs/.ruleml:Timer"
						},
						{
							"items": {
								"$ref": "#/$defs/.ruleml:Timer"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:slot.type.def": {
			"additionalProperties": false,
			"properties": {
				"@card": {
					"$ref": "#/$defs/ruleml:cardinality.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"ruleml:After": {
					"anyOf": [
						{
							"$ref": "#/$defs/.ruleml:After"
						},
						{
							"items": {
								"$ref": "#/$defs/.ruleml:After"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Any": {
					"anyOf": [
						{
							"$ref": "#/$defs/.ruleml:Any"
						},
						{
							"items": {
								"$ref": "#/$defs/.ruleml:Any"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Before": {
					"anyOf": [
						{
							"$ref": "#/$defs/.ruleml:Before"
						},
						{
							"items": {
								"$ref": "#/$defs/.ruleml:Before"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Data": {
					"anyOf": [
						{
							"$ref": "#/$defs/xs:anyType"
						},
						{
							"items": {
								"$ref": "#/$defs/xs:anyType"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Every": {
					"anyOf": [
						{
							"$ref": "#/$defs/.ruleml:Every"
						},
						{
							"items": {
								"$ref": "#/$defs/.ruleml:Every"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Expr": {
					"anyOf": [
						{
							"$ref": "#/$defs/.ruleml:Expr"
						},
						{
							"items": {
								"$ref": "#/$defs/.ruleml:Expr"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Ind": {
					"anyOf": [
						{
							"$ref": "#/$defs/.ruleml:Ind"
						},
						{
							"items": {
								"$ref": "#/$defs/.ruleml:Ind"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Interval": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:Interval_term.type.def",
							"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:Interval_term.type.def",
								"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Plex": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:Plex_Any.type.def",
							"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:Plex_Any.type.def",
								"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:Spatial_term.type.def",
							"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:Spatial_term.type.def",
								"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Time": {
					"anyOf": [
						{
							"$ref": "#/$defs/ruleml:Time_term.type.def",
							"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
						},
						{
							"items": {
								"$ref": "#/$defs/ruleml:Time_term.type.def",
								"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Timer": {
					"anyOf": [
						{
							"$ref": "#/$defs/.ruleml:Timer"
						},
						{
							"items": {
								"$ref": "#/$defs/.ruleml:Timer"
							},
							"type": "array"
						}
					]
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:slotDeontic.type.def": {
			"additionalProperties": false,
			"properties": {
				"@card": {
					"$ref": "#/$defs/ruleml:cardinality.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:AuxiliaryParty": {
					"$ref": "#/$defs/.lrml:AuxiliaryParty"
				},
				"lrml:Bearer": {
					"$ref": "#/$defs/.lrml:Bearer"
				},
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:spatial_anycontent.content": {
			"additionalProperties": false,
			"patternProperties": {
				"^\\w+$": {
				}
			},
			"properties": {
				"$": {
					"type": [
						"string",
						"number",
						"boolean"
					]
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:spatial_anycontent.type": {
			"additionalProperties": false,
			"patternProperties": {
				"^\\w+$": {
				}
			},
			"properties": {
				"$": {
					"type": [
						"string",
						"number",
						"boolean"
					]
				},
				"@index": {
					"$ref": "#/$defs/ruleml:index.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"required": [
				"@index"
			],
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:spatial_primitives.content": {
			"additionalProperties": false,
			"properties": {
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:strong-const.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:strong.content": {
			"additionalProperties": false,
			"description": "The negation role contains a single formula. ",
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:strong.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:style.value": {
			"anyOf": [
				{
					"minLength": 1,
					"pattern": "^((([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)?\\:)(/|[\\w\\D]|[\\w\\D]*|[\\w\\D]|[\\w\\D]*|[\\w\\D]?))$",
					"type": "string"
				},
				{
					"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]+\\:[\\w\\D]+)$",
					"type": "string"
				}
			]
		},
		"ruleml:then_Rule.content": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:SuborderList": {
					"$ref": "#/$defs/.lrml:SuborderList"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:then_Rule.type.def": {
			"additionalProperties": false,
			"properties": {
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				},
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:SuborderList": {
					"$ref": "#/$defs/.lrml:SuborderList"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:time": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:time"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:time_anycontent.content": {
			"additionalProperties": false,
			"patternProperties": {
				"^\\w+$": {
				}
			},
			"properties": {
				"$": {
					"type": [
						"string",
						"number",
						"boolean"
					]
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:time_anycontent.type": {
			"additionalProperties": false,
			"patternProperties": {
				"^\\w+$": {
				}
			},
			"properties": {
				"$": {
					"type": [
						"string",
						"number",
						"boolean"
					]
				},
				"@index": {
					"$ref": "#/$defs/ruleml:index.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"required": [
				"@index"
			],
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:time_primitives.content": {
			"additionalProperties": false,
			"properties": {
				"ruleml:After": {
					"$ref": "#/$defs/.ruleml:After"
				},
				"ruleml:Any": {
					"$ref": "#/$defs/.ruleml:Any"
				},
				"ruleml:Before": {
					"$ref": "#/$defs/.ruleml:Before"
				},
				"ruleml:Data": {
					"$ref": "#/$defs/xs:anyType"
				},
				"ruleml:Every": {
					"$ref": "#/$defs/.ruleml:Every"
				},
				"ruleml:Expr": {
					"$ref": "#/$defs/.ruleml:Expr"
				},
				"ruleml:Ind": {
					"$ref": "#/$defs/.ruleml:Ind"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_term.type.def",
					"description": "<Interval>: generic Interval element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Interval"
				},
				"ruleml:Plex": {
					"$ref": "#/$defs/ruleml:Plex_Any.type.def",
					"description": "A collection of (ordered) arguments (optionally enclosed by\n                        <arg>) and/or (unordered) user-defined slots (<slot>),  identical to an\n                        uninterpreted expression (<Expr in=\"no\">) except not having a user-specified\n                        function name (equivalent  to having a system-specified constructor 'Plex').\n                        Rest variables (<repo> and <resl>) are also permitted.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Plex within\n                        Atom"
				},
				"ruleml:Skolem": {
					"$ref": "#/$defs/.ruleml:Skolem"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_term.type.def",
					"description": "<Spatial>: generic Spatial element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Spatial"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_term.type.def",
					"description": "<Time>: generic Time element. See\n                        http://consumer.ruleml.org/1.02/glossary/#gloss-Time"
				},
				"ruleml:Timer": {
					"$ref": "#/$defs/.ruleml:Timer"
				},
				"ruleml:Var": {
					"$ref": "#/$defs/.ruleml:Var"
				}
			},
			"type": "object"
		},
		"ruleml:torso-const.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"additionalProperties": false,
					"description": "logical conjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_And-const.type.def",
									"description": "a formula of the conjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_And-const.type.def",
										"description": "a formula of the conjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"additionalProperties": false,
					"description": "logical equivalence within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:torso": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:torso-const.type.def",
									"description": "a formula of the equivalence."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:torso-const.type.def",
										"description": "a formula of the equivalence."
									},
									"minItems": 1,
									"type": "array"
								}
							]
						}
					},
					"required": [
						"ruleml:torso"
					],
					"type": "object"
				},
				"ruleml:Exists": {
					"additionalProperties": false,
					"description": "existential quantification within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Exists-const.type.def",
							"description": "the formula of the existential."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"additionalProperties": false,
					"description": "universal quantification within a Constitutive Statement.\n                    ",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:declare": {
							"anyOf": [
								{
									"$ref": "#/$defs/.ruleml:declare"
								},
								{
									"items": {
										"$ref": "#/$defs/.ruleml:declare"
									},
									"minItems": 1,
									"type": "array"
								}
							]
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"$ref": "#/$defs/ruleml:formula_Forall-const.type.def",
							"description": "the formula of the universal."
						}
					},
					"required": [
						"ruleml:declare",
						"ruleml:formula"
					],
					"type": "object"
				},
				"ruleml:Implies": {
					"additionalProperties": false,
					"description": "logical implication within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@material": {
							"$ref": "#/$defs/ruleml:material.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:if": {
							"$ref": "#/$defs/ruleml:body_Implies-const.type.def",
							"description": "the premise (antecedent) of a Rule."
						},
						"ruleml:then": {
							"$ref": "#/$defs/ruleml:head_Implies-const.type.def",
							"description": "the conclusion (consequent) of a Rule."
						}
					},
					"required": [
						"ruleml:if",
						"ruleml:then"
					],
					"type": "object"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"additionalProperties": false,
					"description": "logical negation within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:strong": {
							"$ref": "#/$defs/ruleml:strong-const.type.def",
							"description": "the formula of the strong negation."
						}
					},
					"required": [
						"ruleml:strong"
					],
					"type": "object"
				},
				"ruleml:Or": {
					"additionalProperties": false,
					"description": "logical disjunction within a Constitutive\n                        Statement.",
					"properties": {
						"@closure": {
							"$ref": "#/$defs/ruleml:closure.value"
						},
						"@key": {
							"$ref": "#/$defs/ruleml:key.value"
						},
						"@keyref": {
							"$ref": "#/$defs/ruleml:keyref.value"
						},
						"@style": {
							"$ref": "#/$defs/ruleml:style.value"
						},
						"@xml:id": {
							"$ref": "#/$defs/xs:ID"
						},
						"lrml:hasComment": {
							"$ref": "#/$defs/.lrml:hasComment"
						},
						"lrml:hasParaphrase": {
							"$ref": "#/$defs/.lrml:hasParaphrase"
						},
						"ruleml:degree": {
							"$ref": "#/$defs/.ruleml:degree"
						},
						"ruleml:formula": {
							"anyOf": [
								{
									"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
									"description": "a formula of the disjunction."
								},
								{
									"items": {
										"$ref": "#/$defs/ruleml:formula_Or-const.type.def",
										"description": "a formula of the disjunction."
									},
									"type": "array"
								}
							]
						}
					},
					"type": "object"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:torso.content": {
			"additionalProperties": false,
			"description": "An equivalance is syntactic sugar for two implications. In all RuleML\n                languages, formulas allowed as premises are the same or more general than those\n                allowed as conclusions, because this is a requirement for the statement \"P implies\n                P\" to be syntactically valid whenever P is a valid conclusion. Therefore, formulas\n                allowed in equivalences are the same as those allowed in\n                conclusions.",
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:torso.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Compliance": {
					"$ref": "#/$defs/.lrml:Compliance"
				},
				"lrml:Obligation": {
					"$ref": "#/$defs/.lrml:Obligation"
				},
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"lrml:Permission": {
					"$ref": "#/$defs/.lrml:Permission"
				},
				"lrml:Prohibition": {
					"$ref": "#/$defs/.lrml:Prohibition"
				},
				"lrml:Reparation": {
					"$ref": "#/$defs/.lrml:Reparation"
				},
				"lrml:Right": {
					"$ref": "#/$defs/.lrml:Right"
				},
				"lrml:Violation": {
					"$ref": "#/$defs/.lrml:Violation"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:type.value": {
			"anyOf": [
				{
					"minLength": 1,
					"pattern": "^((([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)?\\:)(/|[\\w\\D]|[\\w\\D]*|[\\w\\D]|[\\w\\D]*|[\\w\\D]?))$",
					"type": "string"
				},
				{
					"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]+\\:[\\w\\D]+)$",
					"type": "string"
				}
			]
		},
		"ruleml:unsignedByte": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:unsignedByte"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:unsignedInt": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:unsignedInt"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:unsignedLong": {
			"additionalProperties": false,
			"properties": {
				"$": {
					"$ref": "#/$defs/xs:unsignedLong"
				},
				"@key": {
					"$ref": "#/$defs/ruleml:key.value"
				},
				"@keyref": {
					"$ref": "#/$defs/ruleml:keyref.value"
				},
				"@xml:id": {
					"$ref": "#/$defs/xs:ID"
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"ruleml:weak.content": {
			"additionalProperties": false,
			"description": "The negation role contains a single formula. ",
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"ruleml:weak.type.def": {
			"additionalProperties": false,
			"properties": {
				"lrml:Override": {
					"$ref": "#/$defs/.lrml:Override"
				},
				"ruleml:And": {
					"$ref": "#/$defs/ruleml:And.type.def",
					"description": "<And>: polyadic conjunction where <And/> is true. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-And"
				},
				"ruleml:Atom": {
					"$ref": "#/$defs/.ruleml:Atom"
				},
				"ruleml:During": {
					"$ref": "#/$defs/.ruleml:During"
				},
				"ruleml:Equal": {
					"$ref": "#/$defs/.ruleml:Equal"
				},
				"ruleml:Equivalent": {
					"$ref": "#/$defs/ruleml:Equivalent.type.def",
					"description": "<Equivalent>: Syntactic sugar for two implications. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Equivalent\n                    "
				},
				"ruleml:Exists": {
					"$ref": "#/$defs/ruleml:Exists.type.def",
					"description": "Explicit existential quantifier. It consists of one or more\n                        variables (<Var>), each optionally surrounded by a <declare> role, followed by a\n                        logical formula  (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Exists"
				},
				"ruleml:Finishes": {
					"$ref": "#/$defs/.ruleml:Finishes"
				},
				"ruleml:Forall": {
					"$ref": "#/$defs/ruleml:Forall.type.def",
					"description": "Explicit universal quantifier. It consists of a sequence of\n                        one or more  variables (<Var>), each optionally surrounded by a <declare> role,\n                        and a logical formula (optionally surrounded by a <formula> role). See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Forall"
				},
				"ruleml:Implies": {
					"$ref": "#/$defs/ruleml:Implies.type.def",
					"description": "<Implies>: an implication between two formulas, a premise and a\n                        conclusion. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Implies"
				},
				"ruleml:Interval": {
					"$ref": "#/$defs/ruleml:Interval_formula.type.def"
				},
				"ruleml:Meets": {
					"$ref": "#/$defs/.ruleml:Meets"
				},
				"ruleml:Neg": {
					"$ref": "#/$defs/ruleml:Neg.type.def",
					"description": "A classical negation of a logical atom (<Atom>) (i.e. classical\n                        or \"strong\" negation).  The negated atom may be optionally surrounded by a\n                        <strong> role.        See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Neg"
				},
				"ruleml:Negation": {
					"$ref": "#/$defs/.ruleml:Negation"
				},
				"ruleml:Operation": {
					"$ref": "#/$defs/.ruleml:Operation"
				},
				"ruleml:Or": {
					"$ref": "#/$defs/ruleml:Or.type.def",
					"description": "<Or>: polyadic disjunction where <Or/> is false. See\n                        http://deliberation.ruleml.org/1.02/glossary/#gloss-Or"
				},
				"ruleml:Overlaps": {
					"$ref": "#/$defs/.ruleml:Overlaps"
				},
				"ruleml:Precedes": {
					"$ref": "#/$defs/.ruleml:Precedes"
				},
				"ruleml:Spatial": {
					"$ref": "#/$defs/ruleml:Spatial_formula.type.def"
				},
				"ruleml:Starts": {
					"$ref": "#/$defs/.ruleml:Starts"
				},
				"ruleml:Succeeds": {
					"$ref": "#/$defs/.ruleml:Succeeds"
				},
				"ruleml:Time": {
					"$ref": "#/$defs/ruleml:Time_formula.type.def"
				}
			},
			"type": "object"
		},
		"xs:ENTITIES": {
			"items": {
				"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)$",
				"type": "string"
			},
			"type": "array"
		},
		"xs:ENTITY": {
			"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)$",
			"type": "string"
		},
		"xs:ID": {
			"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)$",
			"type": "string"
		},
		"xs:NCName": {
			"pattern": "^([A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)$",
			"type": "string"
		},
		"xs:NMTOKEN": {
			"pattern": "^([\\d\\--\\.\\:A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]+)$",
			"type": "string"
		},
		"xs:NMTOKENS": {
			"items": {
				"pattern": "^([\\d\\--\\.\\:A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]+)$",
				"type": "string"
			},
			"type": "array"
		},
		"xs:NOTATION": {
			"type": "string"
		},
		"xs:Name": {
			"pattern": "^([\\:A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ- 𐀀-󯿿][\\d\\--\\.\\:A-Z_a-z·À-ÖØ-öø-ͽͿ-ٟ٪-ۯۺ-޿ߊ-॥॰-৥ৰ-੥ੰ-૥૰-୥୰-௥௰-౥౰-೥೰-൥൰-෥෰-๏๚-໏໚-༟༪-ဿ၊-ႏႚ-៟៪-᠏᠚-᥅ᥐ-᧏᧚-᩿᪊-᪏᪚-᭏᭚-ᮯᮺ-᰿᱊-ᱏᱚ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-ꘟꘪ-꣏꣚-ꣿꤊ-ꧏ꧚-ꧯꧺ-꩏꩚-꯯꯺-퟿豈-﷏ﷰ-／：- 𐀀-𐒟𐒪-𑁥𑁰-𑃯𑃺-𑄵𑅀-𑇏𑇚-𑋯𑋺-𑑏𑑚-𑓏𑓚-𑙏𑙚-𑚿𑛊-𑜯𑜺-𑣟𑣪-𑱏𑱚-𖩟𖩪-𖭏𖭚-𝟍𝠀-𞥏𞥚-󯿿]*)$",
			"type": "string"
		},
		"xs:QName": {
			"type": "string"
		},
		"xs:anySimpleType": {
			"type": [
				"string",
				"number",
				"boolean"
			]
		},
		"xs:anyType": {
			"additionalProperties": false,
			"patternProperties": {
				"^@\\w+$": {
					"type": [
						"string",
						"number",
						"boolean"
					]
				},
				"^\\w+$": {
				}
			},
			"properties": {
				"$": {
					"type": [
						"string",
						"number",
						"boolean"
					]
				}
			},
			"type": [
				"object",
				"string",
				"number",
				"boolean"
			]
		},
		"xs:anyURI": {
			"type": "string"
		},
		"xs:base64Binary": {
			"type": "string"
		},
		"xs:boolean": {
			"type": "boolean"
		},
		"xs:byte": {
			"maximum": 127,
			"minimum": -128,
			"type": "integer"
		},
		"xs:date": {
			"type": "string"
		},
		"xs:dateTime": {
			"type": "string"
		},
		"xs:decimal": {
			"type": "number"
		},
		"xs:double": {
			"type": "number"
		},
		"xs:duration": {
			"type": "string"
		},
		"xs:float": {
			"type": "number"
		},
		"xs:gDay": {
			"type": "string"
		},
		"xs:gMonth": {
			"type": "string"
		},
		"xs:gYear": {
			"type": "string"
		},
		"xs:gYearMonth": {
			"type": "string"
		},
		"xs:hexBinary": {
			"type": "string"
		},
		"xs:int": {
			"maximum": 2147483647,
			"minimum": -2147483648,
			"type": "integer"
		},
		"xs:integer": {
			"type": "integer"
		},
		"xs:language": {
			"pattern": "^([A-Za-z]{1,8}(\\-[0-9A-Za-z]{1,8})*)$",
			"type": "string"
		},
		"xs:long": {
			"maximum": 9223372036854775807,
			"minimum": -9223372036854775808,
			"type": "integer"
		},
		"xs:negativeInteger": {
			"maximum": -1,
			"type": "integer"
		},
		"xs:nonNegativeInteger": {
			"minimum": 0,
			"type": "integer"
		},
		"xs:nonPositiveInteger": {
			"maximum": 0,
			"type": "integer"
		},
		"xs:normalizedString": {
			"type": "string"
		},
		"xs:positiveInteger": {
			"minimum": 1,
			"type": "integer"
		},
		"xs:short": {
			"maximum": 32767,
			"minimum": -32768,
			"type": "integer"
		},
		"xs:string": {
			"type": "string"
		},
		"xs:time": {
			"type": "string"
		},
		"xs:token": {
			"type": "string"
		},
		"xs:unsignedByte": {
			"maximum": 255,
			"minimum": 0,
			"type": "integer"
		},
		"xs:unsignedInt": {
			"maximum": 4294967295,
			"minimum": 0,
			"type": "integer"
		},
		"xs:unsignedLong": {
			"maximum": 18446744073709551615,
			"minimum": 0,
			"type": "integer"
		}
	},
	"$schema": "https://json-schema.org/draft/2020-12/schema",
	"additionalProperties": false,
	"description": "JSON Schema generated by XMLSpy v2022 rel. 2 (x64) (http://www.altova.com)",
	"properties": {
		"@xmlns:lrml": {
			"default": "http://docs.oasis-open.org/legalruleml/ns/v1.0/"
		},
		"@xmlns:n1": {
			"default": "http://www.w3.org/2001/XMLSchema-datatypes"
		},
		"@xmlns:ruleml": {
			"default": "http://ruleml.org/spec"
		},
		"@xmlns:xml": {
			"default": "http://www.w3.org/XML/1998/namespace"
		},
		"@xmlns:xs": {
			"default": "http://www.w3.org/2001/XMLSchema"
		},
		"lrml:Agent": {
			"$ref": "#/$defs/.lrml:Agent"
		},
		"lrml:Agents": {
			"$ref": "#/$defs/.lrml:Agents"
		},
		"lrml:Alternatives": {
			"$ref": "#/$defs/.lrml:Alternatives"
		},
		"lrml:Association": {
			"$ref": "#/$defs/.lrml:Association"
		},
		"lrml:Associations": {
			"$ref": "#/$defs/.lrml:Associations"
		},
		"lrml:Authorities": {
			"$ref": "#/$defs/.lrml:Authorities"
		},
		"lrml:Authority": {
			"$ref": "#/$defs/.lrml:Authority"
		},
		"lrml:AuxiliaryParty": {
			"$ref": "#/$defs/.lrml:AuxiliaryParty"
		},
		"lrml:Bearer": {
			"$ref": "#/$defs/.lrml:Bearer"
		},
		"lrml:Comment": {
			"$ref": "#/$defs/.lrml:Comment"
		},
		"lrml:Compliance": {
			"$ref": "#/$defs/.lrml:Compliance"
		},
		"lrml:ConstitutiveStatement": {
			"$ref": "#/$defs/.lrml:ConstitutiveStatement"
		},
		"lrml:Context": {
			"$ref": "#/$defs/.lrml:Context"
		},
		"lrml:DefeasibleStrength": {
			"$ref": "#/$defs/.lrml:DefeasibleStrength"
		},
		"lrml:Defeater": {
			"$ref": "#/$defs/.lrml:Defeater"
		},
		"lrml:FactualStatement": {
			"$ref": "#/$defs/.lrml:FactualStatement"
		},
		"lrml:Figure": {
			"$ref": "#/$defs/.lrml:Figure"
		},
		"lrml:Figures": {
			"$ref": "#/$defs/.lrml:Figures"
		},
		"lrml:Jurisdiction": {
			"$ref": "#/$defs/.lrml:Jurisdiction"
		},
		"lrml:Jurisdictions": {
			"$ref": "#/$defs/.lrml:Jurisdictions"
		},
		"lrml:LegalReference": {
			"$ref": "#/$defs/.lrml:LegalReference"
		},
		"lrml:LegalReferences": {
			"$ref": "#/$defs/.lrml:LegalReferences"
		},
		"lrml:LegalRuleML": {
			"$ref": "#/$defs/.lrml:LegalRuleML"
		},
		"lrml:LegalSource": {
			"$ref": "#/$defs/.lrml:LegalSource"
		},
		"lrml:LegalSources": {
			"$ref": "#/$defs/.lrml:LegalSources"
		},
		"lrml:Obligation": {
			"$ref": "#/$defs/.lrml:Obligation"
		},
		"lrml:Override": {
			"$ref": "#/$defs/.lrml:Override"
		},
		"lrml:OverrideStatement": {
			"$ref": "#/$defs/.lrml:OverrideStatement"
		},
		"lrml:Paraphrase": {
			"$ref": "#/$defs/.lrml:Paraphrase"
		},
		"lrml:PenaltyStatement": {
			"$ref": "#/$defs/.lrml:PenaltyStatement"
		},
		"lrml:Permission": {
			"$ref": "#/$defs/.lrml:Permission"
		},
		"lrml:Prefix": {
			"$ref": "#/$defs/.lrml:Prefix"
		},
		"lrml:PrescriptiveStatement": {
			"$ref": "#/$defs/.lrml:PrescriptiveStatement"
		},
		"lrml:Prohibition": {
			"$ref": "#/$defs/.lrml:Prohibition"
		},
		"lrml:Reference": {
			"$ref": "#/$defs/.lrml:Reference"
		},
		"lrml:References": {
			"$ref": "#/$defs/.lrml:References"
		},
		"lrml:Reparation": {
			"$ref": "#/$defs/.lrml:Reparation"
		},
		"lrml:ReparationStatement": {
			"$ref": "#/$defs/.lrml:ReparationStatement"
		},
		"lrml:Right": {
			"$ref": "#/$defs/.lrml:Right"
		},
		"lrml:Role": {
			"$ref": "#/$defs/.lrml:Role"
		},
		"lrml:Roles": {
			"$ref": "#/$defs/.lrml:Roles"
		},
		"lrml:Source": {
			"$ref": "#/$defs/.lrml:Source"
		},
		"lrml:Sources": {
			"$ref": "#/$defs/.lrml:Sources"
		},
		"lrml:Statements": {
			"$ref": "#/$defs/.lrml:Statements"
		},
		"lrml:StrictStrength": {
			"$ref": "#/$defs/.lrml:StrictStrength"
		},
		"lrml:SuborderList": {
			"$ref": "#/$defs/.lrml:SuborderList"
		},
		"lrml:TemporalCharacteristic": {
			"$ref": "#/$defs/.lrml:TemporalCharacteristic"
		},
		"lrml:TemporalCharacteristics": {
			"$ref": "#/$defs/.lrml:TemporalCharacteristics"
		},
		"lrml:Times": {
			"$ref": "#/$defs/.lrml:Times"
		},
		"lrml:Violation": {
			"$ref": "#/$defs/.lrml:Violation"
		},
		"lrml:appliesAlternatives": {
			"$ref": "#/$defs/.lrml:appliesAlternatives"
		},
		"lrml:appliesAssociation": {
			"$ref": "#/$defs/.lrml:appliesAssociation"
		},
		"lrml:appliesAssociations": {
			"$ref": "#/$defs/.lrml:appliesAssociations"
		},
		"lrml:appliesAuthority": {
			"$ref": "#/$defs/.lrml:appliesAuthority"
		},
		"lrml:appliesJurisdiction": {
			"$ref": "#/$defs/.lrml:appliesJurisdiction"
		},
		"lrml:appliesModality": {
			"$ref": "#/$defs/.lrml:appliesModality"
		},
		"lrml:appliesPenalty": {
			"$ref": "#/$defs/.lrml:appliesPenalty"
		},
		"lrml:appliesSource": {
			"$ref": "#/$defs/.lrml:appliesSource"
		},
		"lrml:appliesStrength": {
			"$ref": "#/$defs/.lrml:appliesStrength"
		},
		"lrml:appliesTemporalCharacteristic": {
			"$ref": "#/$defs/.lrml:appliesTemporalCharacteristic"
		},
		"lrml:appliesTemporalCharacteristics": {
			"$ref": "#/$defs/.lrml:appliesTemporalCharacteristics"
		},
		"lrml:atTime": {
			"$ref": "#/$defs/.lrml:atTime"
		},
		"lrml:filledBy": {
			"$ref": "#/$defs/.lrml:filledBy"
		},
		"lrml:forExpression": {
			"$ref": "#/$defs/.lrml:forExpression"
		},
		"lrml:forStatus": {
			"$ref": "#/$defs/.lrml:forStatus"
		},
		"lrml:fromLegalSources": {
			"$ref": "#/$defs/.lrml:fromLegalSources"
		},
		"lrml:hasActor": {
			"$ref": "#/$defs/.lrml:hasActor"
		},
		"lrml:hasAgent": {
			"$ref": "#/$defs/.lrml:hasAgent"
		},
		"lrml:hasAgents": {
			"$ref": "#/$defs/.lrml:hasAgents"
		},
		"lrml:hasAlternative": {
			"$ref": "#/$defs/.lrml:hasAlternative"
		},
		"lrml:hasAlternatives": {
			"$ref": "#/$defs/.lrml:hasAlternatives"
		},
		"lrml:hasAssociation": {
			"$ref": "#/$defs/.lrml:hasAssociation"
		},
		"lrml:hasAssociations": {
			"$ref": "#/$defs/.lrml:hasAssociations"
		},
		"lrml:hasAuthorities": {
			"$ref": "#/$defs/.lrml:hasAuthorities"
		},
		"lrml:hasAuthority": {
			"$ref": "#/$defs/.lrml:hasAuthority"
		},
		"lrml:hasComment": {
			"$ref": "#/$defs/.lrml:hasComment"
		},
		"lrml:hasContext": {
			"$ref": "#/$defs/.lrml:hasContext"
		},
		"lrml:hasFigure": {
			"$ref": "#/$defs/.lrml:hasFigure"
		},
		"lrml:hasFigures": {
			"$ref": "#/$defs/.lrml:hasFigures"
		},
		"lrml:hasFunction": {
			"$ref": "#/$defs/.lrml:hasFunction"
		},
		"lrml:hasJurisdiction": {
			"$ref": "#/$defs/.lrml:hasJurisdiction"
		},
		"lrml:hasJurisdictions": {
			"$ref": "#/$defs/.lrml:hasJurisdictions"
		},
		"lrml:hasLegalReference": {
			"$ref": "#/$defs/.lrml:hasLegalReference"
		},
		"lrml:hasLegalReferences": {
			"$ref": "#/$defs/.lrml:hasLegalReferences"
		},
		"lrml:hasLegalSource": {
			"$ref": "#/$defs/.lrml:hasLegalSource"
		},
		"lrml:hasLegalSources": {
			"$ref": "#/$defs/.lrml:hasLegalSources"
		},
		"lrml:hasMemberType": {
			"$ref": "#/$defs/.lrml:hasMemberType"
		},
		"lrml:hasParaphrase": {
			"$ref": "#/$defs/.lrml:hasParaphrase"
		},
		"lrml:hasPrefix": {
			"$ref": "#/$defs/.lrml:hasPrefix"
		},
		"lrml:hasQualification": {
			"$ref": "#/$defs/.lrml:hasQualification"
		},
		"lrml:hasReference": {
			"$ref": "#/$defs/.lrml:hasReference"
		},
		"lrml:hasReferences": {
			"$ref": "#/$defs/.lrml:hasReferences"
		},
		"lrml:hasRole": {
			"$ref": "#/$defs/.lrml:hasRole"
		},
		"lrml:hasRoles": {
			"$ref": "#/$defs/.lrml:hasRoles"
		},
		"lrml:hasSource": {
			"$ref": "#/$defs/.lrml:hasSource"
		},
		"lrml:hasSources": {
			"$ref": "#/$defs/.lrml:hasSources"
		},
		"lrml:hasStatement": {
			"$ref": "#/$defs/.lrml:hasStatement"
		},
		"lrml:hasStatements": {
			"$ref": "#/$defs/.lrml:hasStatements"
		},
		"lrml:hasStatusDevelopment": {
			"$ref": "#/$defs/.lrml:hasStatusDevelopment"
		},
		"lrml:hasStrength": {
			"$ref": "#/$defs/.lrml:hasStrength"
		},
		"lrml:hasTemporalCharacteristic": {
			"$ref": "#/$defs/.lrml:hasTemporalCharacteristic"
		},
		"lrml:hasTemporalCharacteristics": {
			"$ref": "#/$defs/.lrml:hasTemporalCharacteristics"
		},
		"lrml:hasTime": {
			"$ref": "#/$defs/.lrml:hasTime"
		},
		"lrml:hasTimes": {
			"$ref": "#/$defs/.lrml:hasTimes"
		},
		"lrml:hasType": {
			"$ref": "#/$defs/.lrml:hasType"
		},
		"lrml:inScope": {
			"$ref": "#/$defs/.lrml:inScope"
		},
		"lrml:toPrescriptiveStatement": {
			"$ref": "#/$defs/.lrml:toPrescriptiveStatement"
		},
		"lrml:toTarget": {
			"$ref": "#/$defs/.lrml:toTarget"
		},
		"ruleml:After": {
			"$ref": "#/$defs/.ruleml:After"
		},
		"ruleml:Any": {
			"$ref": "#/$defs/.ruleml:Any"
		},
		"ruleml:Atom": {
			"$ref": "#/$defs/.ruleml:Atom"
		},
		"ruleml:Before": {
			"$ref": "#/$defs/.ruleml:Before"
		},
		"ruleml:During": {
			"$ref": "#/$defs/.ruleml:During"
		},
		"ruleml:Equal": {
			"$ref": "#/$defs/.ruleml:Equal"
		},
		"ruleml:Every": {
			"$ref": "#/$defs/.ruleml:Every"
		},
		"ruleml:Expr": {
			"$ref": "#/$defs/.ruleml:Expr"
		},
		"ruleml:Finishes": {
			"$ref": "#/$defs/.ruleml:Finishes"
		},
		"ruleml:Fun": {
			"$ref": "#/$defs/.ruleml:Fun"
		},
		"ruleml:Ind": {
			"$ref": "#/$defs/.ruleml:Ind"
		},
		"ruleml:Init": {
			"$ref": "#/$defs/.ruleml:Init"
		},
		"ruleml:Meets": {
			"$ref": "#/$defs/.ruleml:Meets"
		},
		"ruleml:Naf": {
			"$ref": "#/$defs/.ruleml:Naf"
		},
		"ruleml:Negation": {
			"$ref": "#/$defs/.ruleml:Negation"
		},
		"ruleml:Operation": {
			"$ref": "#/$defs/.ruleml:Operation"
		},
		"ruleml:Overlaps": {
			"$ref": "#/$defs/.ruleml:Overlaps"
		},
		"ruleml:Precedes": {
			"$ref": "#/$defs/.ruleml:Precedes"
		},
		"ruleml:Rel": {
			"$ref": "#/$defs/.ruleml:Rel"
		},
		"ruleml:Skolem": {
			"$ref": "#/$defs/.ruleml:Skolem"
		},
		"ruleml:Starts": {
			"$ref": "#/$defs/.ruleml:Starts"
		},
		"ruleml:Succeeds": {
			"$ref": "#/$defs/.ruleml:Succeeds"
		},
		"ruleml:Timer": {
			"$ref": "#/$defs/.ruleml:Timer"
		},
		"ruleml:Var": {
			"$ref": "#/$defs/.ruleml:Var"
		},
		"ruleml:declare": {
			"$ref": "#/$defs/.ruleml:declare"
		},
		"ruleml:degree": {
			"$ref": "#/$defs/.ruleml:degree"
		},
		"ruleml:left": {
			"$ref": "#/$defs/.ruleml:left"
		},
		"ruleml:oid": {
			"$ref": "#/$defs/.ruleml:oid"
		},
		"ruleml:repo": {
			"$ref": "#/$defs/.ruleml:repo"
		},
		"ruleml:resl": {
			"$ref": "#/$defs/.ruleml:resl"
		},
		"ruleml:right": {
			"$ref": "#/$defs/.ruleml:right"
		},
		"ruleml:weak": {
			"$ref": "#/$defs/.ruleml:weak"
		}
	},
	"type": "object"
}